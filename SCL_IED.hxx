// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef SCL_IED_HXX
#define SCL_IED_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace SCL
{
  class tIED;
  class tServices;
  class tAccessPoint;
  class tServer;
  class tLDevice;
  class tAccessControl;
  class tAssociation;
  class tAnyLN;
  class tLN;
  class tLN0;
  class tDataSet;
  class tFCDA;
  class tFCCB;
  class tControl;
  class tControlWithTriggerOpt;
  class tTrgOps;
  class tReportControl;
  class tRptEnabled;
  class tClientLN;
  class tLogControl;
  class tInputs;
  class tExtRef;
  class tLog;
  class tControlWithIEDName;
  class tGSEControl;
  class tSampledValueControl;
  class tSettingControl;
  class tSCLControl;
  class tDOI;
  class tSDI;
  class tDAI;
  class tServiceYesNo;
  class tServiceWithMax;
  class tServiceWithMaxAndMaxAttributes;
  class tServiceWithMaxAndModify;
  class tServiceWithMaxAndMaxAttributesAndModify;
  class tClientServices;
  class tServiceSettings;
  class tReportSettings;
  class tLogSettings;
  class tGSESettings;
  class tSMVSettings;
  class tConfLNs;
  class SettingGroups;
  class Authentication;
  class LN0;
  class OptFields;
  class SmvOpts;
  class SmpRate1;
}


#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "SCL_BaseTypes.hxx"

namespace SCL
{
  class tIED: public ::SCL::tNaming
  {
    public:
    // Services
    // 
    typedef ::SCL::tServices Services_type;
    typedef ::xsd::cxx::tree::optional< Services_type > Services_optional;
    typedef ::xsd::cxx::tree::traits< Services_type, char > Services_traits;

    const Services_optional&
    Services () const;

    Services_optional&
    Services ();

    void
    Services (const Services_type& x);

    void
    Services (const Services_optional& x);

    void
    Services (::std::auto_ptr< Services_type > p);

    // AccessPoint
    // 
    typedef ::SCL::tAccessPoint AccessPoint_type;
    typedef ::xsd::cxx::tree::sequence< AccessPoint_type > AccessPoint_sequence;
    typedef AccessPoint_sequence::iterator AccessPoint_iterator;
    typedef AccessPoint_sequence::const_iterator AccessPoint_const_iterator;
    typedef ::xsd::cxx::tree::traits< AccessPoint_type, char > AccessPoint_traits;

    const AccessPoint_sequence&
    AccessPoint () const;

    AccessPoint_sequence&
    AccessPoint ();

    void
    AccessPoint (const AccessPoint_sequence& s);

    // type
    // 
    typedef ::xml_schema::normalized_string type_type;
    typedef ::xsd::cxx::tree::optional< type_type > type_optional;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_optional&
    type () const;

    type_optional&
    type ();

    void
    type (const type_type& x);

    void
    type (const type_optional& x);

    void
    type (::std::auto_ptr< type_type > p);

    // manufacturer
    // 
    typedef ::xml_schema::normalized_string manufacturer_type;
    typedef ::xsd::cxx::tree::optional< manufacturer_type > manufacturer_optional;
    typedef ::xsd::cxx::tree::traits< manufacturer_type, char > manufacturer_traits;

    const manufacturer_optional&
    manufacturer () const;

    manufacturer_optional&
    manufacturer ();

    void
    manufacturer (const manufacturer_type& x);

    void
    manufacturer (const manufacturer_optional& x);

    void
    manufacturer (::std::auto_ptr< manufacturer_type > p);

    // configVersion
    // 
    typedef ::xml_schema::normalized_string configVersion_type;
    typedef ::xsd::cxx::tree::optional< configVersion_type > configVersion_optional;
    typedef ::xsd::cxx::tree::traits< configVersion_type, char > configVersion_traits;

    const configVersion_optional&
    configVersion () const;

    configVersion_optional&
    configVersion ();

    void
    configVersion (const configVersion_type& x);

    void
    configVersion (const configVersion_optional& x);

    void
    configVersion (::std::auto_ptr< configVersion_type > p);

    // Constructors.
    //
    tIED (const name_type&);

    tIED (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    tIED (const tIED& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual tIED*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tIED ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Services_optional Services_;
    AccessPoint_sequence AccessPoint_;
    type_optional type_;
    manufacturer_optional manufacturer_;
    configVersion_optional configVersion_;
  };

  class tServices: public ::xml_schema::type
  {
    public:
    // DynAssociation
    // 
    typedef ::SCL::tServiceYesNo DynAssociation_type;
    typedef ::xsd::cxx::tree::optional< DynAssociation_type > DynAssociation_optional;
    typedef ::xsd::cxx::tree::traits< DynAssociation_type, char > DynAssociation_traits;

    const DynAssociation_optional&
    DynAssociation () const;

    DynAssociation_optional&
    DynAssociation ();

    void
    DynAssociation (const DynAssociation_type& x);

    void
    DynAssociation (const DynAssociation_optional& x);

    void
    DynAssociation (::std::auto_ptr< DynAssociation_type > p);

    // SettingGroups
    // 
    typedef ::SCL::SettingGroups SettingGroups_type;
    typedef ::xsd::cxx::tree::optional< SettingGroups_type > SettingGroups_optional;
    typedef ::xsd::cxx::tree::traits< SettingGroups_type, char > SettingGroups_traits;

    const SettingGroups_optional&
    SettingGroups () const;

    SettingGroups_optional&
    SettingGroups ();

    void
    SettingGroups (const SettingGroups_type& x);

    void
    SettingGroups (const SettingGroups_optional& x);

    void
    SettingGroups (::std::auto_ptr< SettingGroups_type > p);

    // GetDirectory
    // 
    typedef ::SCL::tServiceYesNo GetDirectory_type;
    typedef ::xsd::cxx::tree::optional< GetDirectory_type > GetDirectory_optional;
    typedef ::xsd::cxx::tree::traits< GetDirectory_type, char > GetDirectory_traits;

    const GetDirectory_optional&
    GetDirectory () const;

    GetDirectory_optional&
    GetDirectory ();

    void
    GetDirectory (const GetDirectory_type& x);

    void
    GetDirectory (const GetDirectory_optional& x);

    void
    GetDirectory (::std::auto_ptr< GetDirectory_type > p);

    // GetDataObjectDefinition
    // 
    typedef ::SCL::tServiceYesNo GetDataObjectDefinition_type;
    typedef ::xsd::cxx::tree::optional< GetDataObjectDefinition_type > GetDataObjectDefinition_optional;
    typedef ::xsd::cxx::tree::traits< GetDataObjectDefinition_type, char > GetDataObjectDefinition_traits;

    const GetDataObjectDefinition_optional&
    GetDataObjectDefinition () const;

    GetDataObjectDefinition_optional&
    GetDataObjectDefinition ();

    void
    GetDataObjectDefinition (const GetDataObjectDefinition_type& x);

    void
    GetDataObjectDefinition (const GetDataObjectDefinition_optional& x);

    void
    GetDataObjectDefinition (::std::auto_ptr< GetDataObjectDefinition_type > p);

    // DataObjectDirectory
    // 
    typedef ::SCL::tServiceYesNo DataObjectDirectory_type;
    typedef ::xsd::cxx::tree::optional< DataObjectDirectory_type > DataObjectDirectory_optional;
    typedef ::xsd::cxx::tree::traits< DataObjectDirectory_type, char > DataObjectDirectory_traits;

    const DataObjectDirectory_optional&
    DataObjectDirectory () const;

    DataObjectDirectory_optional&
    DataObjectDirectory ();

    void
    DataObjectDirectory (const DataObjectDirectory_type& x);

    void
    DataObjectDirectory (const DataObjectDirectory_optional& x);

    void
    DataObjectDirectory (::std::auto_ptr< DataObjectDirectory_type > p);

    // GetDataSetValue
    // 
    typedef ::SCL::tServiceYesNo GetDataSetValue_type;
    typedef ::xsd::cxx::tree::optional< GetDataSetValue_type > GetDataSetValue_optional;
    typedef ::xsd::cxx::tree::traits< GetDataSetValue_type, char > GetDataSetValue_traits;

    const GetDataSetValue_optional&
    GetDataSetValue () const;

    GetDataSetValue_optional&
    GetDataSetValue ();

    void
    GetDataSetValue (const GetDataSetValue_type& x);

    void
    GetDataSetValue (const GetDataSetValue_optional& x);

    void
    GetDataSetValue (::std::auto_ptr< GetDataSetValue_type > p);

    // SetDataSetValue
    // 
    typedef ::SCL::tServiceYesNo SetDataSetValue_type;
    typedef ::xsd::cxx::tree::optional< SetDataSetValue_type > SetDataSetValue_optional;
    typedef ::xsd::cxx::tree::traits< SetDataSetValue_type, char > SetDataSetValue_traits;

    const SetDataSetValue_optional&
    SetDataSetValue () const;

    SetDataSetValue_optional&
    SetDataSetValue ();

    void
    SetDataSetValue (const SetDataSetValue_type& x);

    void
    SetDataSetValue (const SetDataSetValue_optional& x);

    void
    SetDataSetValue (::std::auto_ptr< SetDataSetValue_type > p);

    // DataSetDirectory
    // 
    typedef ::SCL::tServiceYesNo DataSetDirectory_type;
    typedef ::xsd::cxx::tree::optional< DataSetDirectory_type > DataSetDirectory_optional;
    typedef ::xsd::cxx::tree::traits< DataSetDirectory_type, char > DataSetDirectory_traits;

    const DataSetDirectory_optional&
    DataSetDirectory () const;

    DataSetDirectory_optional&
    DataSetDirectory ();

    void
    DataSetDirectory (const DataSetDirectory_type& x);

    void
    DataSetDirectory (const DataSetDirectory_optional& x);

    void
    DataSetDirectory (::std::auto_ptr< DataSetDirectory_type > p);

    // ConfDataSet
    // 
    typedef ::SCL::tServiceWithMaxAndMaxAttributesAndModify ConfDataSet_type;
    typedef ::xsd::cxx::tree::optional< ConfDataSet_type > ConfDataSet_optional;
    typedef ::xsd::cxx::tree::traits< ConfDataSet_type, char > ConfDataSet_traits;

    const ConfDataSet_optional&
    ConfDataSet () const;

    ConfDataSet_optional&
    ConfDataSet ();

    void
    ConfDataSet (const ConfDataSet_type& x);

    void
    ConfDataSet (const ConfDataSet_optional& x);

    void
    ConfDataSet (::std::auto_ptr< ConfDataSet_type > p);

    // DynDataSet
    // 
    typedef ::SCL::tServiceWithMaxAndMaxAttributes DynDataSet_type;
    typedef ::xsd::cxx::tree::optional< DynDataSet_type > DynDataSet_optional;
    typedef ::xsd::cxx::tree::traits< DynDataSet_type, char > DynDataSet_traits;

    const DynDataSet_optional&
    DynDataSet () const;

    DynDataSet_optional&
    DynDataSet ();

    void
    DynDataSet (const DynDataSet_type& x);

    void
    DynDataSet (const DynDataSet_optional& x);

    void
    DynDataSet (::std::auto_ptr< DynDataSet_type > p);

    // ReadWrite
    // 
    typedef ::SCL::tServiceYesNo ReadWrite_type;
    typedef ::xsd::cxx::tree::optional< ReadWrite_type > ReadWrite_optional;
    typedef ::xsd::cxx::tree::traits< ReadWrite_type, char > ReadWrite_traits;

    const ReadWrite_optional&
    ReadWrite () const;

    ReadWrite_optional&
    ReadWrite ();

    void
    ReadWrite (const ReadWrite_type& x);

    void
    ReadWrite (const ReadWrite_optional& x);

    void
    ReadWrite (::std::auto_ptr< ReadWrite_type > p);

    // TimerActivatedControl
    // 
    typedef ::SCL::tServiceYesNo TimerActivatedControl_type;
    typedef ::xsd::cxx::tree::optional< TimerActivatedControl_type > TimerActivatedControl_optional;
    typedef ::xsd::cxx::tree::traits< TimerActivatedControl_type, char > TimerActivatedControl_traits;

    const TimerActivatedControl_optional&
    TimerActivatedControl () const;

    TimerActivatedControl_optional&
    TimerActivatedControl ();

    void
    TimerActivatedControl (const TimerActivatedControl_type& x);

    void
    TimerActivatedControl (const TimerActivatedControl_optional& x);

    void
    TimerActivatedControl (::std::auto_ptr< TimerActivatedControl_type > p);

    // ConfReportControl
    // 
    typedef ::SCL::tServiceWithMax ConfReportControl_type;
    typedef ::xsd::cxx::tree::optional< ConfReportControl_type > ConfReportControl_optional;
    typedef ::xsd::cxx::tree::traits< ConfReportControl_type, char > ConfReportControl_traits;

    const ConfReportControl_optional&
    ConfReportControl () const;

    ConfReportControl_optional&
    ConfReportControl ();

    void
    ConfReportControl (const ConfReportControl_type& x);

    void
    ConfReportControl (const ConfReportControl_optional& x);

    void
    ConfReportControl (::std::auto_ptr< ConfReportControl_type > p);

    // GetCBValues
    // 
    typedef ::SCL::tServiceYesNo GetCBValues_type;
    typedef ::xsd::cxx::tree::optional< GetCBValues_type > GetCBValues_optional;
    typedef ::xsd::cxx::tree::traits< GetCBValues_type, char > GetCBValues_traits;

    const GetCBValues_optional&
    GetCBValues () const;

    GetCBValues_optional&
    GetCBValues ();

    void
    GetCBValues (const GetCBValues_type& x);

    void
    GetCBValues (const GetCBValues_optional& x);

    void
    GetCBValues (::std::auto_ptr< GetCBValues_type > p);

    // ConfLogControl
    // 
    typedef ::SCL::tServiceWithMax ConfLogControl_type;
    typedef ::xsd::cxx::tree::optional< ConfLogControl_type > ConfLogControl_optional;
    typedef ::xsd::cxx::tree::traits< ConfLogControl_type, char > ConfLogControl_traits;

    const ConfLogControl_optional&
    ConfLogControl () const;

    ConfLogControl_optional&
    ConfLogControl ();

    void
    ConfLogControl (const ConfLogControl_type& x);

    void
    ConfLogControl (const ConfLogControl_optional& x);

    void
    ConfLogControl (::std::auto_ptr< ConfLogControl_type > p);

    // ReportSettings
    // 
    typedef ::SCL::tReportSettings ReportSettings_type;
    typedef ::xsd::cxx::tree::optional< ReportSettings_type > ReportSettings_optional;
    typedef ::xsd::cxx::tree::traits< ReportSettings_type, char > ReportSettings_traits;

    const ReportSettings_optional&
    ReportSettings () const;

    ReportSettings_optional&
    ReportSettings ();

    void
    ReportSettings (const ReportSettings_type& x);

    void
    ReportSettings (const ReportSettings_optional& x);

    void
    ReportSettings (::std::auto_ptr< ReportSettings_type > p);

    // LogSettings
    // 
    typedef ::SCL::tLogSettings LogSettings_type;
    typedef ::xsd::cxx::tree::optional< LogSettings_type > LogSettings_optional;
    typedef ::xsd::cxx::tree::traits< LogSettings_type, char > LogSettings_traits;

    const LogSettings_optional&
    LogSettings () const;

    LogSettings_optional&
    LogSettings ();

    void
    LogSettings (const LogSettings_type& x);

    void
    LogSettings (const LogSettings_optional& x);

    void
    LogSettings (::std::auto_ptr< LogSettings_type > p);

    // GSESettings
    // 
    typedef ::SCL::tGSESettings GSESettings_type;
    typedef ::xsd::cxx::tree::optional< GSESettings_type > GSESettings_optional;
    typedef ::xsd::cxx::tree::traits< GSESettings_type, char > GSESettings_traits;

    const GSESettings_optional&
    GSESettings () const;

    GSESettings_optional&
    GSESettings ();

    void
    GSESettings (const GSESettings_type& x);

    void
    GSESettings (const GSESettings_optional& x);

    void
    GSESettings (::std::auto_ptr< GSESettings_type > p);

    // SMVSettings
    // 
    typedef ::SCL::tSMVSettings SMVSettings_type;
    typedef ::xsd::cxx::tree::optional< SMVSettings_type > SMVSettings_optional;
    typedef ::xsd::cxx::tree::traits< SMVSettings_type, char > SMVSettings_traits;

    const SMVSettings_optional&
    SMVSettings () const;

    SMVSettings_optional&
    SMVSettings ();

    void
    SMVSettings (const SMVSettings_type& x);

    void
    SMVSettings (const SMVSettings_optional& x);

    void
    SMVSettings (::std::auto_ptr< SMVSettings_type > p);

    // GSEDir
    // 
    typedef ::SCL::tServiceYesNo GSEDir_type;
    typedef ::xsd::cxx::tree::optional< GSEDir_type > GSEDir_optional;
    typedef ::xsd::cxx::tree::traits< GSEDir_type, char > GSEDir_traits;

    const GSEDir_optional&
    GSEDir () const;

    GSEDir_optional&
    GSEDir ();

    void
    GSEDir (const GSEDir_type& x);

    void
    GSEDir (const GSEDir_optional& x);

    void
    GSEDir (::std::auto_ptr< GSEDir_type > p);

    // GOOSE
    // 
    typedef ::SCL::tServiceWithMax GOOSE_type;
    typedef ::xsd::cxx::tree::optional< GOOSE_type > GOOSE_optional;
    typedef ::xsd::cxx::tree::traits< GOOSE_type, char > GOOSE_traits;

    const GOOSE_optional&
    GOOSE () const;

    GOOSE_optional&
    GOOSE ();

    void
    GOOSE (const GOOSE_type& x);

    void
    GOOSE (const GOOSE_optional& x);

    void
    GOOSE (::std::auto_ptr< GOOSE_type > p);

    // GSSE
    // 
    typedef ::SCL::tServiceWithMax GSSE_type;
    typedef ::xsd::cxx::tree::optional< GSSE_type > GSSE_optional;
    typedef ::xsd::cxx::tree::traits< GSSE_type, char > GSSE_traits;

    const GSSE_optional&
    GSSE () const;

    GSSE_optional&
    GSSE ();

    void
    GSSE (const GSSE_type& x);

    void
    GSSE (const GSSE_optional& x);

    void
    GSSE (::std::auto_ptr< GSSE_type > p);

    // FileHandling
    // 
    typedef ::SCL::tServiceYesNo FileHandling_type;
    typedef ::xsd::cxx::tree::optional< FileHandling_type > FileHandling_optional;
    typedef ::xsd::cxx::tree::traits< FileHandling_type, char > FileHandling_traits;

    const FileHandling_optional&
    FileHandling () const;

    FileHandling_optional&
    FileHandling ();

    void
    FileHandling (const FileHandling_type& x);

    void
    FileHandling (const FileHandling_optional& x);

    void
    FileHandling (::std::auto_ptr< FileHandling_type > p);

    // ConfLNs
    // 
    typedef ::SCL::tConfLNs ConfLNs_type;
    typedef ::xsd::cxx::tree::optional< ConfLNs_type > ConfLNs_optional;
    typedef ::xsd::cxx::tree::traits< ConfLNs_type, char > ConfLNs_traits;

    const ConfLNs_optional&
    ConfLNs () const;

    ConfLNs_optional&
    ConfLNs ();

    void
    ConfLNs (const ConfLNs_type& x);

    void
    ConfLNs (const ConfLNs_optional& x);

    void
    ConfLNs (::std::auto_ptr< ConfLNs_type > p);

    // ClientServices
    // 
    typedef ::SCL::tClientServices ClientServices_type;
    typedef ::xsd::cxx::tree::optional< ClientServices_type > ClientServices_optional;
    typedef ::xsd::cxx::tree::traits< ClientServices_type, char > ClientServices_traits;

    const ClientServices_optional&
    ClientServices () const;

    ClientServices_optional&
    ClientServices ();

    void
    ClientServices (const ClientServices_type& x);

    void
    ClientServices (const ClientServices_optional& x);

    void
    ClientServices (::std::auto_ptr< ClientServices_type > p);

    // Constructors.
    //
    tServices ();

    tServices (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    tServices (const tServices& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual tServices*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tServices ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DynAssociation_optional DynAssociation_;
    SettingGroups_optional SettingGroups_;
    GetDirectory_optional GetDirectory_;
    GetDataObjectDefinition_optional GetDataObjectDefinition_;
    DataObjectDirectory_optional DataObjectDirectory_;
    GetDataSetValue_optional GetDataSetValue_;
    SetDataSetValue_optional SetDataSetValue_;
    DataSetDirectory_optional DataSetDirectory_;
    ConfDataSet_optional ConfDataSet_;
    DynDataSet_optional DynDataSet_;
    ReadWrite_optional ReadWrite_;
    TimerActivatedControl_optional TimerActivatedControl_;
    ConfReportControl_optional ConfReportControl_;
    GetCBValues_optional GetCBValues_;
    ConfLogControl_optional ConfLogControl_;
    ReportSettings_optional ReportSettings_;
    LogSettings_optional LogSettings_;
    GSESettings_optional GSESettings_;
    SMVSettings_optional SMVSettings_;
    GSEDir_optional GSEDir_;
    GOOSE_optional GOOSE_;
    GSSE_optional GSSE_;
    FileHandling_optional FileHandling_;
    ConfLNs_optional ConfLNs_;
    ClientServices_optional ClientServices_;
  };

  class tAccessPoint: public ::SCL::tNaming
  {
    public:
    // Server
    // 
    typedef ::SCL::tServer Server_type;
    typedef ::xsd::cxx::tree::optional< Server_type > Server_optional;
    typedef ::xsd::cxx::tree::traits< Server_type, char > Server_traits;

    const Server_optional&
    Server () const;

    Server_optional&
    Server ();

    void
    Server (const Server_type& x);

    void
    Server (const Server_optional& x);

    void
    Server (::std::auto_ptr< Server_type > p);

    // LN
    // 
    typedef ::SCL::tLN LN_type;
    typedef ::xsd::cxx::tree::sequence< LN_type > LN_sequence;
    typedef LN_sequence::iterator LN_iterator;
    typedef LN_sequence::const_iterator LN_const_iterator;
    typedef ::xsd::cxx::tree::traits< LN_type, char > LN_traits;

    const LN_sequence&
    LN () const;

    LN_sequence&
    LN ();

    void
    LN (const LN_sequence& s);

    // router
    // 
    typedef ::xml_schema::boolean router_type;
    typedef ::xsd::cxx::tree::traits< router_type, char > router_traits;

    const router_type&
    router () const;

    router_type&
    router ();

    void
    router (const router_type& x);

    static router_type
    router_default_value ();

    // clock
    // 
    typedef ::xml_schema::boolean clock_type;
    typedef ::xsd::cxx::tree::traits< clock_type, char > clock_traits;

    const clock_type&
    clock () const;

    clock_type&
    clock ();

    void
    clock (const clock_type& x);

    static clock_type
    clock_default_value ();

    // Constructors.
    //
    tAccessPoint (const name_type&);

    tAccessPoint (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    tAccessPoint (const tAccessPoint& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual tAccessPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tAccessPoint ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Server_optional Server_;
    LN_sequence LN_;
    ::xsd::cxx::tree::one< router_type > router_;
    ::xsd::cxx::tree::one< clock_type > clock_;
  };

  class tServer: public ::SCL::tUnNaming
  {
    public:
    // Authentication
    // 
    typedef ::SCL::Authentication Authentication_type;
    typedef ::xsd::cxx::tree::traits< Authentication_type, char > Authentication_traits;

    const Authentication_type&
    Authentication () const;

    Authentication_type&
    Authentication ();

    void
    Authentication (const Authentication_type& x);

    void
    Authentication (::std::auto_ptr< Authentication_type > p);

    // LDevice
    // 
    typedef ::SCL::tLDevice LDevice_type;
    typedef ::xsd::cxx::tree::sequence< LDevice_type > LDevice_sequence;
    typedef LDevice_sequence::iterator LDevice_iterator;
    typedef LDevice_sequence::const_iterator LDevice_const_iterator;
    typedef ::xsd::cxx::tree::traits< LDevice_type, char > LDevice_traits;

    const LDevice_sequence&
    LDevice () const;

    LDevice_sequence&
    LDevice ();

    void
    LDevice (const LDevice_sequence& s);

    // Association
    // 
    typedef ::SCL::tAssociation Association_type;
    typedef ::xsd::cxx::tree::sequence< Association_type > Association_sequence;
    typedef Association_sequence::iterator Association_iterator;
    typedef Association_sequence::const_iterator Association_const_iterator;
    typedef ::xsd::cxx::tree::traits< Association_type, char > Association_traits;

    const Association_sequence&
    Association () const;

    Association_sequence&
    Association ();

    void
    Association (const Association_sequence& s);

    // timeout
    // 
    typedef ::xml_schema::unsigned_int timeout_type;
    typedef ::xsd::cxx::tree::traits< timeout_type, char > timeout_traits;

    const timeout_type&
    timeout () const;

    timeout_type&
    timeout ();

    void
    timeout (const timeout_type& x);

    static timeout_type
    timeout_default_value ();

    // Constructors.
    //
    tServer (const Authentication_type&);

    tServer (::std::auto_ptr< Authentication_type >&);

    tServer (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    tServer (const tServer& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual tServer*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tServer ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Authentication_type > Authentication_;
    LDevice_sequence LDevice_;
    Association_sequence Association_;
    ::xsd::cxx::tree::one< timeout_type > timeout_;
  };

  class tLDevice: public ::SCL::tUnNaming
  {
    public:
    // LN0
    // 
    typedef ::SCL::LN0 LN0_type;
    typedef ::xsd::cxx::tree::traits< LN0_type, char > LN0_traits;

    const LN0_type&
    LN0 () const;

    LN0_type&
    LN0 ();

    void
    LN0 (const LN0_type& x);

    void
    LN0 (::std::auto_ptr< LN0_type > p);

    // LN
    // 
    typedef ::SCL::tLN LN_type;
    typedef ::xsd::cxx::tree::sequence< LN_type > LN_sequence;
    typedef LN_sequence::iterator LN_iterator;
    typedef LN_sequence::const_iterator LN_const_iterator;
    typedef ::xsd::cxx::tree::traits< LN_type, char > LN_traits;

    const LN_sequence&
    LN () const;

    LN_sequence&
    LN ();

    void
    LN (const LN_sequence& s);

    // AccessControl
    // 
    typedef ::SCL::tAccessControl AccessControl_type;
    typedef ::xsd::cxx::tree::optional< AccessControl_type > AccessControl_optional;
    typedef ::xsd::cxx::tree::traits< AccessControl_type, char > AccessControl_traits;

    const AccessControl_optional&
    AccessControl () const;

    AccessControl_optional&
    AccessControl ();

    void
    AccessControl (const AccessControl_type& x);

    void
    AccessControl (const AccessControl_optional& x);

    void
    AccessControl (::std::auto_ptr< AccessControl_type > p);

    // inst
    // 
    typedef ::SCL::tName inst_type;
    typedef ::xsd::cxx::tree::traits< inst_type, char > inst_traits;

    const inst_type&
    inst () const;

    inst_type&
    inst ();

    void
    inst (const inst_type& x);

    void
    inst (::std::auto_ptr< inst_type > p);

    // ldName
    // 
    typedef ::SCL::tRestrLdName ldName_type;
    typedef ::xsd::cxx::tree::optional< ldName_type > ldName_optional;
    typedef ::xsd::cxx::tree::traits< ldName_type, char > ldName_traits;

    const ldName_optional&
    ldName () const;

    ldName_optional&
    ldName ();

    void
    ldName (const ldName_type& x);

    void
    ldName (const ldName_optional& x);

    void
    ldName (::std::auto_ptr< ldName_type > p);

    // Constructors.
    //
    tLDevice (const LN0_type&,
              const inst_type&);

    tLDevice (::std::auto_ptr< LN0_type >&,
              const inst_type&);

    tLDevice (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    tLDevice (const tLDevice& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual tLDevice*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tLDevice ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< LN0_type > LN0_;
    LN_sequence LN_;
    AccessControl_optional AccessControl_;
    ::xsd::cxx::tree::one< inst_type > inst_;
    ldName_optional ldName_;
  };

  class tAccessControl: public ::SCL::tAnyContentFromOtherNamespace
  {
    public:
    // Constructors.
    //
    tAccessControl ();

    tAccessControl (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    tAccessControl (const tAccessControl& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual tAccessControl*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tAccessControl ();
  };

  class tAssociation: public ::xml_schema::type
  {
    public:
    // kind
    // 
    typedef ::SCL::tAssociationKindEnum kind_type;
    typedef ::xsd::cxx::tree::traits< kind_type, char > kind_traits;

    const kind_type&
    kind () const;

    kind_type&
    kind ();

    void
    kind (const kind_type& x);

    void
    kind (::std::auto_ptr< kind_type > p);

    // associationID
    // 
    typedef ::SCL::tName associationID_type;
    typedef ::xsd::cxx::tree::optional< associationID_type > associationID_optional;
    typedef ::xsd::cxx::tree::traits< associationID_type, char > associationID_traits;

    const associationID_optional&
    associationID () const;

    associationID_optional&
    associationID ();

    void
    associationID (const associationID_type& x);

    void
    associationID (const associationID_optional& x);

    void
    associationID (::std::auto_ptr< associationID_type > p);

    // iedName
    // 
    typedef ::SCL::tName iedName_type;
    typedef ::xsd::cxx::tree::traits< iedName_type, char > iedName_traits;

    const iedName_type&
    iedName () const;

    iedName_type&
    iedName ();

    void
    iedName (const iedName_type& x);

    void
    iedName (::std::auto_ptr< iedName_type > p);

    // ldInst
    // 
    typedef ::SCL::tName ldInst_type;
    typedef ::xsd::cxx::tree::traits< ldInst_type, char > ldInst_traits;

    const ldInst_type&
    ldInst () const;

    ldInst_type&
    ldInst ();

    void
    ldInst (const ldInst_type& x);

    void
    ldInst (::std::auto_ptr< ldInst_type > p);

    // prefix
    // 
    typedef ::SCL::tAnyName prefix_type;
    typedef ::xsd::cxx::tree::optional< prefix_type > prefix_optional;
    typedef ::xsd::cxx::tree::traits< prefix_type, char > prefix_traits;

    const prefix_optional&
    prefix () const;

    prefix_optional&
    prefix ();

    void
    prefix (const prefix_type& x);

    void
    prefix (const prefix_optional& x);

    void
    prefix (::std::auto_ptr< prefix_type > p);

    // lnClass
    // 
    typedef ::SCL::tLNClassEnum lnClass_type;
    typedef ::xsd::cxx::tree::traits< lnClass_type, char > lnClass_traits;

    const lnClass_type&
    lnClass () const;

    lnClass_type&
    lnClass ();

    void
    lnClass (const lnClass_type& x);

    void
    lnClass (::std::auto_ptr< lnClass_type > p);

    // lnInst
    // 
    typedef ::SCL::tAnyName lnInst_type;
    typedef ::xsd::cxx::tree::traits< lnInst_type, char > lnInst_traits;

    const lnInst_type&
    lnInst () const;

    lnInst_type&
    lnInst ();

    void
    lnInst (const lnInst_type& x);

    void
    lnInst (::std::auto_ptr< lnInst_type > p);

    // Constructors.
    //
    tAssociation (const kind_type&,
                  const iedName_type&,
                  const ldInst_type&,
                  const lnClass_type&,
                  const lnInst_type&);

    tAssociation (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    tAssociation (const tAssociation& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual tAssociation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tAssociation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< kind_type > kind_;
    associationID_optional associationID_;
    ::xsd::cxx::tree::one< iedName_type > iedName_;
    ::xsd::cxx::tree::one< ldInst_type > ldInst_;
    prefix_optional prefix_;
    ::xsd::cxx::tree::one< lnClass_type > lnClass_;
    ::xsd::cxx::tree::one< lnInst_type > lnInst_;
  };

  class tAnyLN: public ::SCL::tUnNaming
  {
    public:
    // DataSet
    // 
    typedef ::SCL::tDataSet DataSet_type;
    typedef ::xsd::cxx::tree::sequence< DataSet_type > DataSet_sequence;
    typedef DataSet_sequence::iterator DataSet_iterator;
    typedef DataSet_sequence::const_iterator DataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataSet_type, char > DataSet_traits;

    const DataSet_sequence&
    DataSet () const;

    DataSet_sequence&
    DataSet ();

    void
    DataSet (const DataSet_sequence& s);

    // ReportControl
    // 
    typedef ::SCL::tReportControl ReportControl_type;
    typedef ::xsd::cxx::tree::sequence< ReportControl_type > ReportControl_sequence;
    typedef ReportControl_sequence::iterator ReportControl_iterator;
    typedef ReportControl_sequence::const_iterator ReportControl_const_iterator;
    typedef ::xsd::cxx::tree::traits< ReportControl_type, char > ReportControl_traits;

    const ReportControl_sequence&
    ReportControl () const;

    ReportControl_sequence&
    ReportControl ();

    void
    ReportControl (const ReportControl_sequence& s);

    // LogControl
    // 
    typedef ::SCL::tLogControl LogControl_type;
    typedef ::xsd::cxx::tree::sequence< LogControl_type > LogControl_sequence;
    typedef LogControl_sequence::iterator LogControl_iterator;
    typedef LogControl_sequence::const_iterator LogControl_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogControl_type, char > LogControl_traits;

    const LogControl_sequence&
    LogControl () const;

    LogControl_sequence&
    LogControl ();

    void
    LogControl (const LogControl_sequence& s);

    // DOI
    // 
    typedef ::SCL::tDOI DOI_type;
    typedef ::xsd::cxx::tree::sequence< DOI_type > DOI_sequence;
    typedef DOI_sequence::iterator DOI_iterator;
    typedef DOI_sequence::const_iterator DOI_const_iterator;
    typedef ::xsd::cxx::tree::traits< DOI_type, char > DOI_traits;

    const DOI_sequence&
    DOI () const;

    DOI_sequence&
    DOI ();

    void
    DOI (const DOI_sequence& s);

    // Inputs
    // 
    typedef ::SCL::tInputs Inputs_type;
    typedef ::xsd::cxx::tree::optional< Inputs_type > Inputs_optional;
    typedef ::xsd::cxx::tree::traits< Inputs_type, char > Inputs_traits;

    const Inputs_optional&
    Inputs () const;

    Inputs_optional&
    Inputs ();

    void
    Inputs (const Inputs_type& x);

    void
    Inputs (const Inputs_optional& x);

    void
    Inputs (::std::auto_ptr< Inputs_type > p);

    // lnType
    // 
    typedef ::SCL::tName lnType_type;
    typedef ::xsd::cxx::tree::traits< lnType_type, char > lnType_traits;

    const lnType_type&
    lnType () const;

    lnType_type&
    lnType ();

    void
    lnType (const lnType_type& x);

    void
    lnType (::std::auto_ptr< lnType_type > p);

    // Constructors.
    //
    tAnyLN (const lnType_type&);

    tAnyLN (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    tAnyLN (const tAnyLN& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual tAnyLN*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tAnyLN ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DataSet_sequence DataSet_;
    ReportControl_sequence ReportControl_;
    LogControl_sequence LogControl_;
    DOI_sequence DOI_;
    Inputs_optional Inputs_;
    ::xsd::cxx::tree::one< lnType_type > lnType_;
  };

  class tLN: public ::SCL::tAnyLN
  {
    public:
    // lnClass
    // 
    typedef ::SCL::tLNClassEnum lnClass_type;
    typedef ::xsd::cxx::tree::traits< lnClass_type, char > lnClass_traits;

    const lnClass_type&
    lnClass () const;

    lnClass_type&
    lnClass ();

    void
    lnClass (const lnClass_type& x);

    void
    lnClass (::std::auto_ptr< lnClass_type > p);

    // inst
    // 
    typedef ::xml_schema::unsigned_int inst_type;
    typedef ::xsd::cxx::tree::traits< inst_type, char > inst_traits;

    const inst_type&
    inst () const;

    inst_type&
    inst ();

    void
    inst (const inst_type& x);

    // prefix
    // 
    typedef ::SCL::tAnyName prefix_type;
    typedef ::xsd::cxx::tree::optional< prefix_type > prefix_optional;
    typedef ::xsd::cxx::tree::traits< prefix_type, char > prefix_traits;

    const prefix_optional&
    prefix () const;

    prefix_optional&
    prefix ();

    void
    prefix (const prefix_type& x);

    void
    prefix (const prefix_optional& x);

    void
    prefix (::std::auto_ptr< prefix_type > p);

    // Constructors.
    //
    tLN (const lnType_type&,
         const lnClass_type&,
         const inst_type&);

    tLN (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    tLN (const tLN& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    virtual tLN*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tLN ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< lnClass_type > lnClass_;
    ::xsd::cxx::tree::one< inst_type > inst_;
    prefix_optional prefix_;
  };

  class tLN0: public ::SCL::tAnyLN
  {
    public:
    // GSEControl
    // 
    typedef ::SCL::tGSEControl GSEControl_type;
    typedef ::xsd::cxx::tree::sequence< GSEControl_type > GSEControl_sequence;
    typedef GSEControl_sequence::iterator GSEControl_iterator;
    typedef GSEControl_sequence::const_iterator GSEControl_const_iterator;
    typedef ::xsd::cxx::tree::traits< GSEControl_type, char > GSEControl_traits;

    const GSEControl_sequence&
    GSEControl () const;

    GSEControl_sequence&
    GSEControl ();

    void
    GSEControl (const GSEControl_sequence& s);

    // SampledValueControl
    // 
    typedef ::SCL::tSampledValueControl SampledValueControl_type;
    typedef ::xsd::cxx::tree::sequence< SampledValueControl_type > SampledValueControl_sequence;
    typedef SampledValueControl_sequence::iterator SampledValueControl_iterator;
    typedef SampledValueControl_sequence::const_iterator SampledValueControl_const_iterator;
    typedef ::xsd::cxx::tree::traits< SampledValueControl_type, char > SampledValueControl_traits;

    const SampledValueControl_sequence&
    SampledValueControl () const;

    SampledValueControl_sequence&
    SampledValueControl ();

    void
    SampledValueControl (const SampledValueControl_sequence& s);

    // SettingControl
    // 
    typedef ::SCL::tSettingControl SettingControl_type;
    typedef ::xsd::cxx::tree::optional< SettingControl_type > SettingControl_optional;
    typedef ::xsd::cxx::tree::traits< SettingControl_type, char > SettingControl_traits;

    const SettingControl_optional&
    SettingControl () const;

    SettingControl_optional&
    SettingControl ();

    void
    SettingControl (const SettingControl_type& x);

    void
    SettingControl (const SettingControl_optional& x);

    void
    SettingControl (::std::auto_ptr< SettingControl_type > p);

    // SCLControl
    // 
    typedef ::SCL::tSCLControl SCLControl_type;
    typedef ::xsd::cxx::tree::optional< SCLControl_type > SCLControl_optional;
    typedef ::xsd::cxx::tree::traits< SCLControl_type, char > SCLControl_traits;

    const SCLControl_optional&
    SCLControl () const;

    SCLControl_optional&
    SCLControl ();

    void
    SCLControl (const SCLControl_type& x);

    void
    SCLControl (const SCLControl_optional& x);

    void
    SCLControl (::std::auto_ptr< SCLControl_type > p);

    // Log
    // 
    typedef ::SCL::tLog Log_type;
    typedef ::xsd::cxx::tree::optional< Log_type > Log_optional;
    typedef ::xsd::cxx::tree::traits< Log_type, char > Log_traits;

    const Log_optional&
    Log () const;

    Log_optional&
    Log ();

    void
    Log (const Log_type& x);

    void
    Log (const Log_optional& x);

    void
    Log (::std::auto_ptr< Log_type > p);

    // lnClass
    // 
    typedef ::SCL::tLNClassEnum lnClass_type;
    typedef ::xsd::cxx::tree::traits< lnClass_type, char > lnClass_traits;

    const lnClass_type&
    lnClass () const;

    static const lnClass_type&
    lnClass_default_value ();

    // inst
    // 
    typedef ::xml_schema::normalized_string inst_type;
    typedef ::xsd::cxx::tree::traits< inst_type, char > inst_traits;

    const inst_type&
    inst () const;

    static const inst_type&
    inst_default_value ();

    // Constructors.
    //
    tLN0 (const lnType_type&);

    tLN0 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    tLN0 (const tLN0& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual tLN0*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tLN0 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    GSEControl_sequence GSEControl_;
    SampledValueControl_sequence SampledValueControl_;
    SettingControl_optional SettingControl_;
    SCLControl_optional SCLControl_;
    Log_optional Log_;
    ::xsd::cxx::tree::one< lnClass_type > lnClass_;
    static const lnClass_type lnClass_default_value_;
    ::xsd::cxx::tree::one< inst_type > inst_;
    static const inst_type inst_default_value_;
  };

  class tDataSet: public ::SCL::tNaming
  {
    public:
    // FCDA
    // 
    typedef ::SCL::tFCDA FCDA_type;
    typedef ::xsd::cxx::tree::sequence< FCDA_type > FCDA_sequence;
    typedef FCDA_sequence::iterator FCDA_iterator;
    typedef FCDA_sequence::const_iterator FCDA_const_iterator;
    typedef ::xsd::cxx::tree::traits< FCDA_type, char > FCDA_traits;

    const FCDA_sequence&
    FCDA () const;

    FCDA_sequence&
    FCDA ();

    void
    FCDA (const FCDA_sequence& s);

    // FCCB
    // 
    typedef ::SCL::tFCCB FCCB_type;
    typedef ::xsd::cxx::tree::sequence< FCCB_type > FCCB_sequence;
    typedef FCCB_sequence::iterator FCCB_iterator;
    typedef FCCB_sequence::const_iterator FCCB_const_iterator;
    typedef ::xsd::cxx::tree::traits< FCCB_type, char > FCCB_traits;

    const FCCB_sequence&
    FCCB () const;

    FCCB_sequence&
    FCCB ();

    void
    FCCB (const FCCB_sequence& s);

    // Constructors.
    //
    tDataSet (const name_type&);

    tDataSet (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    tDataSet (const tDataSet& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual tDataSet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tDataSet ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FCDA_sequence FCDA_;
    FCCB_sequence FCCB_;
  };

  class tFCDA: public ::xml_schema::type
  {
    public:
    // ldInst
    // 
    typedef ::SCL::tName ldInst_type;
    typedef ::xsd::cxx::tree::optional< ldInst_type > ldInst_optional;
    typedef ::xsd::cxx::tree::traits< ldInst_type, char > ldInst_traits;

    const ldInst_optional&
    ldInst () const;

    ldInst_optional&
    ldInst ();

    void
    ldInst (const ldInst_type& x);

    void
    ldInst (const ldInst_optional& x);

    void
    ldInst (::std::auto_ptr< ldInst_type > p);

    // prefix
    // 
    typedef ::SCL::tAnyName prefix_type;
    typedef ::xsd::cxx::tree::optional< prefix_type > prefix_optional;
    typedef ::xsd::cxx::tree::traits< prefix_type, char > prefix_traits;

    const prefix_optional&
    prefix () const;

    prefix_optional&
    prefix ();

    void
    prefix (const prefix_type& x);

    void
    prefix (const prefix_optional& x);

    void
    prefix (::std::auto_ptr< prefix_type > p);

    // lnClass
    // 
    typedef ::SCL::tLNClassEnum lnClass_type;
    typedef ::xsd::cxx::tree::optional< lnClass_type > lnClass_optional;
    typedef ::xsd::cxx::tree::traits< lnClass_type, char > lnClass_traits;

    const lnClass_optional&
    lnClass () const;

    lnClass_optional&
    lnClass ();

    void
    lnClass (const lnClass_type& x);

    void
    lnClass (const lnClass_optional& x);

    void
    lnClass (::std::auto_ptr< lnClass_type > p);

    // lnInst
    // 
    typedef ::SCL::tName lnInst_type;
    typedef ::xsd::cxx::tree::optional< lnInst_type > lnInst_optional;
    typedef ::xsd::cxx::tree::traits< lnInst_type, char > lnInst_traits;

    const lnInst_optional&
    lnInst () const;

    lnInst_optional&
    lnInst ();

    void
    lnInst (const lnInst_type& x);

    void
    lnInst (const lnInst_optional& x);

    void
    lnInst (::std::auto_ptr< lnInst_type > p);

    // doName
    // 
    typedef ::SCL::tName doName_type;
    typedef ::xsd::cxx::tree::optional< doName_type > doName_optional;
    typedef ::xsd::cxx::tree::traits< doName_type, char > doName_traits;

    const doName_optional&
    doName () const;

    doName_optional&
    doName ();

    void
    doName (const doName_type& x);

    void
    doName (const doName_optional& x);

    void
    doName (::std::auto_ptr< doName_type > p);

    // daName
    // 
    typedef ::SCL::tName daName_type;
    typedef ::xsd::cxx::tree::optional< daName_type > daName_optional;
    typedef ::xsd::cxx::tree::traits< daName_type, char > daName_traits;

    const daName_optional&
    daName () const;

    daName_optional&
    daName ();

    void
    daName (const daName_type& x);

    void
    daName (const daName_optional& x);

    void
    daName (::std::auto_ptr< daName_type > p);

    // fc
    // 
    typedef ::SCL::tFCEnum fc_type;
    typedef ::xsd::cxx::tree::traits< fc_type, char > fc_traits;

    const fc_type&
    fc () const;

    fc_type&
    fc ();

    void
    fc (const fc_type& x);

    void
    fc (::std::auto_ptr< fc_type > p);

    // Constructors.
    //
    tFCDA (const fc_type&);

    tFCDA (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    tFCDA (const tFCDA& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual tFCDA*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tFCDA ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ldInst_optional ldInst_;
    prefix_optional prefix_;
    lnClass_optional lnClass_;
    lnInst_optional lnInst_;
    doName_optional doName_;
    daName_optional daName_;
    ::xsd::cxx::tree::one< fc_type > fc_;
  };

  class tFCCB: public ::xml_schema::type
  {
    public:
    // ldInst
    // 
    typedef ::SCL::tName ldInst_type;
    typedef ::xsd::cxx::tree::traits< ldInst_type, char > ldInst_traits;

    const ldInst_type&
    ldInst () const;

    ldInst_type&
    ldInst ();

    void
    ldInst (const ldInst_type& x);

    void
    ldInst (::std::auto_ptr< ldInst_type > p);

    // prefix
    // 
    typedef ::SCL::tAnyName prefix_type;
    typedef ::xsd::cxx::tree::optional< prefix_type > prefix_optional;
    typedef ::xsd::cxx::tree::traits< prefix_type, char > prefix_traits;

    const prefix_optional&
    prefix () const;

    prefix_optional&
    prefix ();

    void
    prefix (const prefix_type& x);

    void
    prefix (const prefix_optional& x);

    void
    prefix (::std::auto_ptr< prefix_type > p);

    // lnClass
    // 
    typedef ::SCL::tLNClassEnum lnClass_type;
    typedef ::xsd::cxx::tree::traits< lnClass_type, char > lnClass_traits;

    const lnClass_type&
    lnClass () const;

    lnClass_type&
    lnClass ();

    void
    lnClass (const lnClass_type& x);

    void
    lnClass (::std::auto_ptr< lnClass_type > p);

    // lnInst
    // 
    typedef ::SCL::tName lnInst_type;
    typedef ::xsd::cxx::tree::optional< lnInst_type > lnInst_optional;
    typedef ::xsd::cxx::tree::traits< lnInst_type, char > lnInst_traits;

    const lnInst_optional&
    lnInst () const;

    lnInst_optional&
    lnInst ();

    void
    lnInst (const lnInst_type& x);

    void
    lnInst (const lnInst_optional& x);

    void
    lnInst (::std::auto_ptr< lnInst_type > p);

    // cbName
    // 
    typedef ::SCL::tName cbName_type;
    typedef ::xsd::cxx::tree::traits< cbName_type, char > cbName_traits;

    const cbName_type&
    cbName () const;

    cbName_type&
    cbName ();

    void
    cbName (const cbName_type& x);

    void
    cbName (::std::auto_ptr< cbName_type > p);

    // daName
    // 
    typedef ::SCL::tName daName_type;
    typedef ::xsd::cxx::tree::optional< daName_type > daName_optional;
    typedef ::xsd::cxx::tree::traits< daName_type, char > daName_traits;

    const daName_optional&
    daName () const;

    daName_optional&
    daName ();

    void
    daName (const daName_type& x);

    void
    daName (const daName_optional& x);

    void
    daName (::std::auto_ptr< daName_type > p);

    // fc
    // 
    typedef ::SCL::tServiceFCEnum fc_type;
    typedef ::xsd::cxx::tree::traits< fc_type, char > fc_traits;

    const fc_type&
    fc () const;

    fc_type&
    fc ();

    void
    fc (const fc_type& x);

    void
    fc (::std::auto_ptr< fc_type > p);

    // Constructors.
    //
    tFCCB (const ldInst_type&,
           const lnClass_type&,
           const cbName_type&,
           const fc_type&);

    tFCCB (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    tFCCB (const tFCCB& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual tFCCB*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tFCCB ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ldInst_type > ldInst_;
    prefix_optional prefix_;
    ::xsd::cxx::tree::one< lnClass_type > lnClass_;
    lnInst_optional lnInst_;
    ::xsd::cxx::tree::one< cbName_type > cbName_;
    daName_optional daName_;
    ::xsd::cxx::tree::one< fc_type > fc_;
  };

  class tControl: public ::SCL::tNaming
  {
    public:
    // datSet
    // 
    typedef ::SCL::tName datSet_type;
    typedef ::xsd::cxx::tree::optional< datSet_type > datSet_optional;
    typedef ::xsd::cxx::tree::traits< datSet_type, char > datSet_traits;

    const datSet_optional&
    datSet () const;

    datSet_optional&
    datSet ();

    void
    datSet (const datSet_type& x);

    void
    datSet (const datSet_optional& x);

    void
    datSet (::std::auto_ptr< datSet_type > p);

    // Constructors.
    //
    tControl (const name_type&);

    tControl (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    tControl (const tControl& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual tControl*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tControl ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    datSet_optional datSet_;
  };

  class tControlWithTriggerOpt: public ::SCL::tControl
  {
    public:
    // TrgOps
    // 
    typedef ::SCL::tTrgOps TrgOps_type;
    typedef ::xsd::cxx::tree::optional< TrgOps_type > TrgOps_optional;
    typedef ::xsd::cxx::tree::traits< TrgOps_type, char > TrgOps_traits;

    const TrgOps_optional&
    TrgOps () const;

    TrgOps_optional&
    TrgOps ();

    void
    TrgOps (const TrgOps_type& x);

    void
    TrgOps (const TrgOps_optional& x);

    void
    TrgOps (::std::auto_ptr< TrgOps_type > p);

    // intgPd
    // 
    typedef ::xml_schema::unsigned_int intgPd_type;
    typedef ::xsd::cxx::tree::traits< intgPd_type, char > intgPd_traits;

    const intgPd_type&
    intgPd () const;

    intgPd_type&
    intgPd ();

    void
    intgPd (const intgPd_type& x);

    static intgPd_type
    intgPd_default_value ();

    // Constructors.
    //
    tControlWithTriggerOpt (const name_type&);

    tControlWithTriggerOpt (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    tControlWithTriggerOpt (const tControlWithTriggerOpt& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual tControlWithTriggerOpt*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tControlWithTriggerOpt ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    TrgOps_optional TrgOps_;
    ::xsd::cxx::tree::one< intgPd_type > intgPd_;
  };

  class tTrgOps: public ::xml_schema::type
  {
    public:
    // dchg
    // 
    typedef ::xml_schema::boolean dchg_type;
    typedef ::xsd::cxx::tree::traits< dchg_type, char > dchg_traits;

    const dchg_type&
    dchg () const;

    dchg_type&
    dchg ();

    void
    dchg (const dchg_type& x);

    static dchg_type
    dchg_default_value ();

    // qchg
    // 
    typedef ::xml_schema::boolean qchg_type;
    typedef ::xsd::cxx::tree::traits< qchg_type, char > qchg_traits;

    const qchg_type&
    qchg () const;

    qchg_type&
    qchg ();

    void
    qchg (const qchg_type& x);

    static qchg_type
    qchg_default_value ();

    // dupd
    // 
    typedef ::xml_schema::boolean dupd_type;
    typedef ::xsd::cxx::tree::traits< dupd_type, char > dupd_traits;

    const dupd_type&
    dupd () const;

    dupd_type&
    dupd ();

    void
    dupd (const dupd_type& x);

    static dupd_type
    dupd_default_value ();

    // period
    // 
    typedef ::xml_schema::boolean period_type;
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    const period_type&
    period () const;

    period_type&
    period ();

    void
    period (const period_type& x);

    static period_type
    period_default_value ();

    // Constructors.
    //
    tTrgOps ();

    tTrgOps (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    tTrgOps (const tTrgOps& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual tTrgOps*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tTrgOps ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< dchg_type > dchg_;
    ::xsd::cxx::tree::one< qchg_type > qchg_;
    ::xsd::cxx::tree::one< dupd_type > dupd_;
    ::xsd::cxx::tree::one< period_type > period_;
  };

  class tReportControl: public ::SCL::tControlWithTriggerOpt
  {
    public:
    // OptFields
    // 
    typedef ::SCL::OptFields OptFields_type;
    typedef ::xsd::cxx::tree::traits< OptFields_type, char > OptFields_traits;

    const OptFields_type&
    OptFields () const;

    OptFields_type&
    OptFields ();

    void
    OptFields (const OptFields_type& x);

    void
    OptFields (::std::auto_ptr< OptFields_type > p);

    // RptEnabled
    // 
    typedef ::SCL::tRptEnabled RptEnabled_type;
    typedef ::xsd::cxx::tree::optional< RptEnabled_type > RptEnabled_optional;
    typedef ::xsd::cxx::tree::traits< RptEnabled_type, char > RptEnabled_traits;

    const RptEnabled_optional&
    RptEnabled () const;

    RptEnabled_optional&
    RptEnabled ();

    void
    RptEnabled (const RptEnabled_type& x);

    void
    RptEnabled (const RptEnabled_optional& x);

    void
    RptEnabled (::std::auto_ptr< RptEnabled_type > p);

    // rptID
    // 
    typedef ::SCL::tName rptID_type;
    typedef ::xsd::cxx::tree::traits< rptID_type, char > rptID_traits;

    const rptID_type&
    rptID () const;

    rptID_type&
    rptID ();

    void
    rptID (const rptID_type& x);

    void
    rptID (::std::auto_ptr< rptID_type > p);

    // confRev
    // 
    typedef ::xml_schema::unsigned_int confRev_type;
    typedef ::xsd::cxx::tree::traits< confRev_type, char > confRev_traits;

    const confRev_type&
    confRev () const;

    confRev_type&
    confRev ();

    void
    confRev (const confRev_type& x);

    // buffered
    // 
    typedef ::xml_schema::boolean buffered_type;
    typedef ::xsd::cxx::tree::traits< buffered_type, char > buffered_traits;

    const buffered_type&
    buffered () const;

    buffered_type&
    buffered ();

    void
    buffered (const buffered_type& x);

    static buffered_type
    buffered_default_value ();

    // bufTime
    // 
    typedef ::xml_schema::unsigned_int bufTime_type;
    typedef ::xsd::cxx::tree::traits< bufTime_type, char > bufTime_traits;

    const bufTime_type&
    bufTime () const;

    bufTime_type&
    bufTime ();

    void
    bufTime (const bufTime_type& x);

    static bufTime_type
    bufTime_default_value ();

    // Constructors.
    //
    tReportControl (const name_type&,
                    const OptFields_type&,
                    const rptID_type&,
                    const confRev_type&);

    tReportControl (const name_type&,
                    ::std::auto_ptr< OptFields_type >&,
                    const rptID_type&,
                    const confRev_type&);

    tReportControl (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    tReportControl (const tReportControl& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual tReportControl*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tReportControl ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< OptFields_type > OptFields_;
    RptEnabled_optional RptEnabled_;
    ::xsd::cxx::tree::one< rptID_type > rptID_;
    ::xsd::cxx::tree::one< confRev_type > confRev_;
    ::xsd::cxx::tree::one< buffered_type > buffered_;
    ::xsd::cxx::tree::one< bufTime_type > bufTime_;
  };

  class tRptEnabled: public ::SCL::tUnNaming
  {
    public:
    // ClientLN
    // 
    typedef ::SCL::tClientLN ClientLN_type;
    typedef ::xsd::cxx::tree::sequence< ClientLN_type > ClientLN_sequence;
    typedef ClientLN_sequence::iterator ClientLN_iterator;
    typedef ClientLN_sequence::const_iterator ClientLN_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClientLN_type, char > ClientLN_traits;

    const ClientLN_sequence&
    ClientLN () const;

    ClientLN_sequence&
    ClientLN ();

    void
    ClientLN (const ClientLN_sequence& s);

    // max
    // 
    typedef ::xml_schema::unsigned_int max_type;
    typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

    const max_type&
    max () const;

    max_type&
    max ();

    void
    max (const max_type& x);

    static max_type
    max_default_value ();

    // Constructors.
    //
    tRptEnabled ();

    tRptEnabled (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    tRptEnabled (const tRptEnabled& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual tRptEnabled*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tRptEnabled ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ClientLN_sequence ClientLN_;
    ::xsd::cxx::tree::one< max_type > max_;
  };

  class tClientLN: public ::xml_schema::type
  {
    public:
    // iedName
    // 
    typedef ::SCL::tName iedName_type;
    typedef ::xsd::cxx::tree::traits< iedName_type, char > iedName_traits;

    const iedName_type&
    iedName () const;

    iedName_type&
    iedName ();

    void
    iedName (const iedName_type& x);

    void
    iedName (::std::auto_ptr< iedName_type > p);

    // ldInst
    // 
    typedef ::SCL::tName ldInst_type;
    typedef ::xsd::cxx::tree::traits< ldInst_type, char > ldInst_traits;

    const ldInst_type&
    ldInst () const;

    ldInst_type&
    ldInst ();

    void
    ldInst (const ldInst_type& x);

    void
    ldInst (::std::auto_ptr< ldInst_type > p);

    // prefix
    // 
    typedef ::SCL::tAnyName prefix_type;
    typedef ::xsd::cxx::tree::optional< prefix_type > prefix_optional;
    typedef ::xsd::cxx::tree::traits< prefix_type, char > prefix_traits;

    const prefix_optional&
    prefix () const;

    prefix_optional&
    prefix ();

    void
    prefix (const prefix_type& x);

    void
    prefix (const prefix_optional& x);

    void
    prefix (::std::auto_ptr< prefix_type > p);

    // lnClass
    // 
    typedef ::SCL::tLNClassEnum lnClass_type;
    typedef ::xsd::cxx::tree::traits< lnClass_type, char > lnClass_traits;

    const lnClass_type&
    lnClass () const;

    lnClass_type&
    lnClass ();

    void
    lnClass (const lnClass_type& x);

    void
    lnClass (::std::auto_ptr< lnClass_type > p);

    // lnInst
    // 
    typedef ::SCL::tAnyName lnInst_type;
    typedef ::xsd::cxx::tree::traits< lnInst_type, char > lnInst_traits;

    const lnInst_type&
    lnInst () const;

    lnInst_type&
    lnInst ();

    void
    lnInst (const lnInst_type& x);

    void
    lnInst (::std::auto_ptr< lnInst_type > p);

    // Constructors.
    //
    tClientLN (const iedName_type&,
               const ldInst_type&,
               const lnClass_type&,
               const lnInst_type&);

    tClientLN (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    tClientLN (const tClientLN& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual tClientLN*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tClientLN ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< iedName_type > iedName_;
    ::xsd::cxx::tree::one< ldInst_type > ldInst_;
    prefix_optional prefix_;
    ::xsd::cxx::tree::one< lnClass_type > lnClass_;
    ::xsd::cxx::tree::one< lnInst_type > lnInst_;
  };

  class tLogControl: public ::SCL::tControlWithTriggerOpt
  {
    public:
    // logName
    // 
    typedef ::SCL::tName logName_type;
    typedef ::xsd::cxx::tree::traits< logName_type, char > logName_traits;

    const logName_type&
    logName () const;

    logName_type&
    logName ();

    void
    logName (const logName_type& x);

    void
    logName (::std::auto_ptr< logName_type > p);

    // logEna
    // 
    typedef ::xml_schema::boolean logEna_type;
    typedef ::xsd::cxx::tree::traits< logEna_type, char > logEna_traits;

    const logEna_type&
    logEna () const;

    logEna_type&
    logEna ();

    void
    logEna (const logEna_type& x);

    static logEna_type
    logEna_default_value ();

    // reasonCode
    // 
    typedef ::xml_schema::boolean reasonCode_type;
    typedef ::xsd::cxx::tree::traits< reasonCode_type, char > reasonCode_traits;

    const reasonCode_type&
    reasonCode () const;

    reasonCode_type&
    reasonCode ();

    void
    reasonCode (const reasonCode_type& x);

    static reasonCode_type
    reasonCode_default_value ();

    // Constructors.
    //
    tLogControl (const name_type&,
                 const logName_type&);

    tLogControl (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    tLogControl (const tLogControl& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual tLogControl*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tLogControl ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< logName_type > logName_;
    ::xsd::cxx::tree::one< logEna_type > logEna_;
    ::xsd::cxx::tree::one< reasonCode_type > reasonCode_;
  };

  class tInputs: public ::SCL::tUnNaming
  {
    public:
    // ExtRef
    // 
    typedef ::SCL::tExtRef ExtRef_type;
    typedef ::xsd::cxx::tree::sequence< ExtRef_type > ExtRef_sequence;
    typedef ExtRef_sequence::iterator ExtRef_iterator;
    typedef ExtRef_sequence::const_iterator ExtRef_const_iterator;
    typedef ::xsd::cxx::tree::traits< ExtRef_type, char > ExtRef_traits;

    const ExtRef_sequence&
    ExtRef () const;

    ExtRef_sequence&
    ExtRef ();

    void
    ExtRef (const ExtRef_sequence& s);

    // Constructors.
    //
    tInputs ();

    tInputs (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    tInputs (const tInputs& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual tInputs*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tInputs ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ExtRef_sequence ExtRef_;
  };

  class tExtRef: public ::xml_schema::type
  {
    public:
    // iedName
    // 
    typedef ::SCL::tName iedName_type;
    typedef ::xsd::cxx::tree::traits< iedName_type, char > iedName_traits;

    const iedName_type&
    iedName () const;

    iedName_type&
    iedName ();

    void
    iedName (const iedName_type& x);

    void
    iedName (::std::auto_ptr< iedName_type > p);

    // ldInst
    // 
    typedef ::SCL::tName ldInst_type;
    typedef ::xsd::cxx::tree::traits< ldInst_type, char > ldInst_traits;

    const ldInst_type&
    ldInst () const;

    ldInst_type&
    ldInst ();

    void
    ldInst (const ldInst_type& x);

    void
    ldInst (::std::auto_ptr< ldInst_type > p);

    // prefix
    // 
    typedef ::SCL::tAnyName prefix_type;
    typedef ::xsd::cxx::tree::optional< prefix_type > prefix_optional;
    typedef ::xsd::cxx::tree::traits< prefix_type, char > prefix_traits;

    const prefix_optional&
    prefix () const;

    prefix_optional&
    prefix ();

    void
    prefix (const prefix_type& x);

    void
    prefix (const prefix_optional& x);

    void
    prefix (::std::auto_ptr< prefix_type > p);

    // lnClass
    // 
    typedef ::SCL::tLNClassEnum lnClass_type;
    typedef ::xsd::cxx::tree::traits< lnClass_type, char > lnClass_traits;

    const lnClass_type&
    lnClass () const;

    lnClass_type&
    lnClass ();

    void
    lnClass (const lnClass_type& x);

    void
    lnClass (::std::auto_ptr< lnClass_type > p);

    // lnInst
    // 
    typedef ::SCL::tAnyName lnInst_type;
    typedef ::xsd::cxx::tree::traits< lnInst_type, char > lnInst_traits;

    const lnInst_type&
    lnInst () const;

    lnInst_type&
    lnInst ();

    void
    lnInst (const lnInst_type& x);

    void
    lnInst (::std::auto_ptr< lnInst_type > p);

    // doName
    // 
    typedef ::SCL::tName doName_type;
    typedef ::xsd::cxx::tree::traits< doName_type, char > doName_traits;

    const doName_type&
    doName () const;

    doName_type&
    doName ();

    void
    doName (const doName_type& x);

    void
    doName (::std::auto_ptr< doName_type > p);

    // daName
    // 
    typedef ::SCL::tName daName_type;
    typedef ::xsd::cxx::tree::optional< daName_type > daName_optional;
    typedef ::xsd::cxx::tree::traits< daName_type, char > daName_traits;

    const daName_optional&
    daName () const;

    daName_optional&
    daName ();

    void
    daName (const daName_type& x);

    void
    daName (const daName_optional& x);

    void
    daName (::std::auto_ptr< daName_type > p);

    // intAddr
    // 
    typedef ::xml_schema::normalized_string intAddr_type;
    typedef ::xsd::cxx::tree::optional< intAddr_type > intAddr_optional;
    typedef ::xsd::cxx::tree::traits< intAddr_type, char > intAddr_traits;

    const intAddr_optional&
    intAddr () const;

    intAddr_optional&
    intAddr ();

    void
    intAddr (const intAddr_type& x);

    void
    intAddr (const intAddr_optional& x);

    void
    intAddr (::std::auto_ptr< intAddr_type > p);

    // Constructors.
    //
    tExtRef (const iedName_type&,
             const ldInst_type&,
             const lnClass_type&,
             const lnInst_type&,
             const doName_type&);

    tExtRef (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    tExtRef (const tExtRef& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual tExtRef*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tExtRef ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< iedName_type > iedName_;
    ::xsd::cxx::tree::one< ldInst_type > ldInst_;
    prefix_optional prefix_;
    ::xsd::cxx::tree::one< lnClass_type > lnClass_;
    ::xsd::cxx::tree::one< lnInst_type > lnInst_;
    ::xsd::cxx::tree::one< doName_type > doName_;
    daName_optional daName_;
    intAddr_optional intAddr_;
  };

  class tLog: public ::SCL::tAnyContentFromOtherNamespace
  {
    public:
    // Constructors.
    //
    tLog ();

    tLog (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    tLog (const tLog& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual tLog*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tLog ();
  };

  class tControlWithIEDName: public ::SCL::tControl
  {
    public:
    // IEDName
    // 
    typedef ::SCL::tName IEDName_type;
    typedef ::xsd::cxx::tree::sequence< IEDName_type > IEDName_sequence;
    typedef IEDName_sequence::iterator IEDName_iterator;
    typedef IEDName_sequence::const_iterator IEDName_const_iterator;
    typedef ::xsd::cxx::tree::traits< IEDName_type, char > IEDName_traits;

    const IEDName_sequence&
    IEDName () const;

    IEDName_sequence&
    IEDName ();

    void
    IEDName (const IEDName_sequence& s);

    // confRev
    // 
    typedef ::xml_schema::unsigned_int confRev_type;
    typedef ::xsd::cxx::tree::optional< confRev_type > confRev_optional;
    typedef ::xsd::cxx::tree::traits< confRev_type, char > confRev_traits;

    const confRev_optional&
    confRev () const;

    confRev_optional&
    confRev ();

    void
    confRev (const confRev_type& x);

    void
    confRev (const confRev_optional& x);

    // Constructors.
    //
    tControlWithIEDName (const name_type&);

    tControlWithIEDName (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    tControlWithIEDName (const tControlWithIEDName& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual tControlWithIEDName*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tControlWithIEDName ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    IEDName_sequence IEDName_;
    confRev_optional confRev_;
  };

  class tGSEControl: public ::SCL::tControlWithIEDName
  {
    public:
    // type
    // 
    typedef ::SCL::tGSEControlTypeEnum type_type;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_type&
    type () const;

    type_type&
    type ();

    void
    type (const type_type& x);

    void
    type (::std::auto_ptr< type_type > p);

    static const type_type&
    type_default_value ();

    // appID
    // 
    typedef ::xml_schema::normalized_string appID_type;
    typedef ::xsd::cxx::tree::traits< appID_type, char > appID_traits;

    const appID_type&
    appID () const;

    appID_type&
    appID ();

    void
    appID (const appID_type& x);

    void
    appID (::std::auto_ptr< appID_type > p);

    // Constructors.
    //
    tGSEControl (const name_type&,
                 const appID_type&);

    tGSEControl (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    tGSEControl (const tGSEControl& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual tGSEControl*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tGSEControl ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< type_type > type_;
    static const type_type type_default_value_;
    ::xsd::cxx::tree::one< appID_type > appID_;
  };

  class tSampledValueControl: public ::SCL::tControlWithIEDName
  {
    public:
    // SmvOpts
    // 
    typedef ::SCL::SmvOpts SmvOpts_type;
    typedef ::xsd::cxx::tree::traits< SmvOpts_type, char > SmvOpts_traits;

    const SmvOpts_type&
    SmvOpts () const;

    SmvOpts_type&
    SmvOpts ();

    void
    SmvOpts (const SmvOpts_type& x);

    void
    SmvOpts (::std::auto_ptr< SmvOpts_type > p);

    // smvID
    // 
    typedef ::xml_schema::normalized_string smvID_type;
    typedef ::xsd::cxx::tree::traits< smvID_type, char > smvID_traits;

    const smvID_type&
    smvID () const;

    smvID_type&
    smvID ();

    void
    smvID (const smvID_type& x);

    void
    smvID (::std::auto_ptr< smvID_type > p);

    // multicast
    // 
    typedef ::xml_schema::boolean multicast_type;
    typedef ::xsd::cxx::tree::traits< multicast_type, char > multicast_traits;

    const multicast_type&
    multicast () const;

    multicast_type&
    multicast ();

    void
    multicast (const multicast_type& x);

    static multicast_type
    multicast_default_value ();

    // smpRate
    // 
    typedef ::xml_schema::unsigned_int smpRate_type;
    typedef ::xsd::cxx::tree::traits< smpRate_type, char > smpRate_traits;

    const smpRate_type&
    smpRate () const;

    smpRate_type&
    smpRate ();

    void
    smpRate (const smpRate_type& x);

    // nofASDU
    // 
    typedef ::xml_schema::unsigned_int nofASDU_type;
    typedef ::xsd::cxx::tree::traits< nofASDU_type, char > nofASDU_traits;

    const nofASDU_type&
    nofASDU () const;

    nofASDU_type&
    nofASDU ();

    void
    nofASDU (const nofASDU_type& x);

    // Constructors.
    //
    tSampledValueControl (const name_type&,
                          const SmvOpts_type&,
                          const smvID_type&,
                          const smpRate_type&,
                          const nofASDU_type&);

    tSampledValueControl (const name_type&,
                          ::std::auto_ptr< SmvOpts_type >&,
                          const smvID_type&,
                          const smpRate_type&,
                          const nofASDU_type&);

    tSampledValueControl (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    tSampledValueControl (const tSampledValueControl& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual tSampledValueControl*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tSampledValueControl ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< SmvOpts_type > SmvOpts_;
    ::xsd::cxx::tree::one< smvID_type > smvID_;
    ::xsd::cxx::tree::one< multicast_type > multicast_;
    ::xsd::cxx::tree::one< smpRate_type > smpRate_;
    ::xsd::cxx::tree::one< nofASDU_type > nofASDU_;
  };

  class tSettingControl: public ::SCL::tUnNaming
  {
    public:
    // numOfSGs
    // 
    typedef ::xml_schema::unsigned_int numOfSGs_type;
    typedef ::xsd::cxx::tree::traits< numOfSGs_type, char > numOfSGs_traits;

    const numOfSGs_type&
    numOfSGs () const;

    numOfSGs_type&
    numOfSGs ();

    void
    numOfSGs (const numOfSGs_type& x);

    // actSG
    // 
    typedef ::xml_schema::unsigned_int actSG_type;
    typedef ::xsd::cxx::tree::traits< actSG_type, char > actSG_traits;

    const actSG_type&
    actSG () const;

    actSG_type&
    actSG ();

    void
    actSG (const actSG_type& x);

    static actSG_type
    actSG_default_value ();

    // Constructors.
    //
    tSettingControl (const numOfSGs_type&);

    tSettingControl (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    tSettingControl (const tSettingControl& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual tSettingControl*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tSettingControl ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< numOfSGs_type > numOfSGs_;
    ::xsd::cxx::tree::one< actSG_type > actSG_;
  };

  class tSCLControl: public ::SCL::tUnNaming
  {
    public:
    // Constructors.
    //
    tSCLControl ();

    tSCLControl (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    tSCLControl (const tSCLControl& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual tSCLControl*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tSCLControl ();
  };

  class tDOI: public ::SCL::tUnNaming
  {
    public:
    // SDI
    // 
    typedef ::SCL::tSDI SDI_type;
    typedef ::xsd::cxx::tree::sequence< SDI_type > SDI_sequence;
    typedef SDI_sequence::iterator SDI_iterator;
    typedef SDI_sequence::const_iterator SDI_const_iterator;
    typedef ::xsd::cxx::tree::traits< SDI_type, char > SDI_traits;

    const SDI_sequence&
    SDI () const;

    SDI_sequence&
    SDI ();

    void
    SDI (const SDI_sequence& s);

    // DAI
    // 
    typedef ::SCL::tDAI DAI_type;
    typedef ::xsd::cxx::tree::sequence< DAI_type > DAI_sequence;
    typedef DAI_sequence::iterator DAI_iterator;
    typedef DAI_sequence::const_iterator DAI_const_iterator;
    typedef ::xsd::cxx::tree::traits< DAI_type, char > DAI_traits;

    const DAI_sequence&
    DAI () const;

    DAI_sequence&
    DAI ();

    void
    DAI (const DAI_sequence& s);

    // name
    // 
    typedef ::SCL::tRestrName1stU name_type;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_type&
    name () const;

    name_type&
    name ();

    void
    name (const name_type& x);

    void
    name (::std::auto_ptr< name_type > p);

    // ix
    // 
    typedef ::xml_schema::unsigned_int ix_type;
    typedef ::xsd::cxx::tree::optional< ix_type > ix_optional;
    typedef ::xsd::cxx::tree::traits< ix_type, char > ix_traits;

    const ix_optional&
    ix () const;

    ix_optional&
    ix ();

    void
    ix (const ix_type& x);

    void
    ix (const ix_optional& x);

    // accessControl
    // 
    typedef ::xml_schema::normalized_string accessControl_type;
    typedef ::xsd::cxx::tree::optional< accessControl_type > accessControl_optional;
    typedef ::xsd::cxx::tree::traits< accessControl_type, char > accessControl_traits;

    const accessControl_optional&
    accessControl () const;

    accessControl_optional&
    accessControl ();

    void
    accessControl (const accessControl_type& x);

    void
    accessControl (const accessControl_optional& x);

    void
    accessControl (::std::auto_ptr< accessControl_type > p);

    // Constructors.
    //
    tDOI (const name_type&);

    tDOI (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    tDOI (const tDOI& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual tDOI*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tDOI ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SDI_sequence SDI_;
    DAI_sequence DAI_;
    ::xsd::cxx::tree::one< name_type > name_;
    ix_optional ix_;
    accessControl_optional accessControl_;
  };

  class tSDI: public ::SCL::tUnNaming
  {
    public:
    // SDI
    // 
    typedef ::SCL::tSDI SDI_type;
    typedef ::xsd::cxx::tree::sequence< SDI_type > SDI_sequence;
    typedef SDI_sequence::iterator SDI_iterator;
    typedef SDI_sequence::const_iterator SDI_const_iterator;
    typedef ::xsd::cxx::tree::traits< SDI_type, char > SDI_traits;

    const SDI_sequence&
    SDI () const;

    SDI_sequence&
    SDI ();

    void
    SDI (const SDI_sequence& s);

    // DAI
    // 
    typedef ::SCL::tDAI DAI_type;
    typedef ::xsd::cxx::tree::sequence< DAI_type > DAI_sequence;
    typedef DAI_sequence::iterator DAI_iterator;
    typedef DAI_sequence::const_iterator DAI_const_iterator;
    typedef ::xsd::cxx::tree::traits< DAI_type, char > DAI_traits;

    const DAI_sequence&
    DAI () const;

    DAI_sequence&
    DAI ();

    void
    DAI (const DAI_sequence& s);

    // name
    // 
    typedef ::SCL::tAttributeNameEnum name_type;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_type&
    name () const;

    name_type&
    name ();

    void
    name (const name_type& x);

    void
    name (::std::auto_ptr< name_type > p);

    // ix
    // 
    typedef ::xml_schema::unsigned_int ix_type;
    typedef ::xsd::cxx::tree::optional< ix_type > ix_optional;
    typedef ::xsd::cxx::tree::traits< ix_type, char > ix_traits;

    const ix_optional&
    ix () const;

    ix_optional&
    ix ();

    void
    ix (const ix_type& x);

    void
    ix (const ix_optional& x);

    // Constructors.
    //
    tSDI (const name_type&);

    tSDI (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    tSDI (const tSDI& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual tSDI*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tSDI ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SDI_sequence SDI_;
    DAI_sequence DAI_;
    ::xsd::cxx::tree::one< name_type > name_;
    ix_optional ix_;
  };

  class tDAI: public ::SCL::tUnNaming
  {
    public:
    // Val
    // 
    typedef ::SCL::tVal Val_type;
    typedef ::xsd::cxx::tree::sequence< Val_type > Val_sequence;
    typedef Val_sequence::iterator Val_iterator;
    typedef Val_sequence::const_iterator Val_const_iterator;
    typedef ::xsd::cxx::tree::traits< Val_type, char > Val_traits;

    const Val_sequence&
    Val () const;

    Val_sequence&
    Val ();

    void
    Val (const Val_sequence& s);

    // name
    // 
    typedef ::SCL::tAttributeNameEnum name_type;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_type&
    name () const;

    name_type&
    name ();

    void
    name (const name_type& x);

    void
    name (::std::auto_ptr< name_type > p);

    // sAddr
    // 
    typedef ::xml_schema::normalized_string sAddr_type;
    typedef ::xsd::cxx::tree::optional< sAddr_type > sAddr_optional;
    typedef ::xsd::cxx::tree::traits< sAddr_type, char > sAddr_traits;

    const sAddr_optional&
    sAddr () const;

    sAddr_optional&
    sAddr ();

    void
    sAddr (const sAddr_type& x);

    void
    sAddr (const sAddr_optional& x);

    void
    sAddr (::std::auto_ptr< sAddr_type > p);

    // valKind
    // 
    typedef ::SCL::tValKindEnum valKind_type;
    typedef ::xsd::cxx::tree::traits< valKind_type, char > valKind_traits;

    const valKind_type&
    valKind () const;

    valKind_type&
    valKind ();

    void
    valKind (const valKind_type& x);

    void
    valKind (::std::auto_ptr< valKind_type > p);

    static const valKind_type&
    valKind_default_value ();

    // ix
    // 
    typedef ::xml_schema::unsigned_int ix_type;
    typedef ::xsd::cxx::tree::optional< ix_type > ix_optional;
    typedef ::xsd::cxx::tree::traits< ix_type, char > ix_traits;

    const ix_optional&
    ix () const;

    ix_optional&
    ix ();

    void
    ix (const ix_type& x);

    void
    ix (const ix_optional& x);

    // Constructors.
    //
    tDAI (const name_type&);

    tDAI (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    tDAI (const tDAI& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual tDAI*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tDAI ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Val_sequence Val_;
    ::xsd::cxx::tree::one< name_type > name_;
    sAddr_optional sAddr_;
    ::xsd::cxx::tree::one< valKind_type > valKind_;
    static const valKind_type valKind_default_value_;
    ix_optional ix_;
  };

  class tServiceYesNo: public ::xml_schema::type
  {
    public:
    // Constructors.
    //
    tServiceYesNo ();

    tServiceYesNo (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    tServiceYesNo (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    tServiceYesNo (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    tServiceYesNo (const tServiceYesNo& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual tServiceYesNo*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tServiceYesNo ();
  };

  class tServiceWithMax: public ::xml_schema::type
  {
    public:
    // max
    // 
    typedef ::xml_schema::unsigned_int max_type;
    typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

    const max_type&
    max () const;

    max_type&
    max ();

    void
    max (const max_type& x);

    // Constructors.
    //
    tServiceWithMax (const max_type&);

    tServiceWithMax (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    tServiceWithMax (const tServiceWithMax& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual tServiceWithMax*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tServiceWithMax ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< max_type > max_;
  };

  class tServiceWithMaxAndMaxAttributes: public ::SCL::tServiceWithMax
  {
    public:
    // maxAttributes
    // 
    typedef ::xml_schema::unsigned_int maxAttributes_type;
    typedef ::xsd::cxx::tree::optional< maxAttributes_type > maxAttributes_optional;
    typedef ::xsd::cxx::tree::traits< maxAttributes_type, char > maxAttributes_traits;

    const maxAttributes_optional&
    maxAttributes () const;

    maxAttributes_optional&
    maxAttributes ();

    void
    maxAttributes (const maxAttributes_type& x);

    void
    maxAttributes (const maxAttributes_optional& x);

    // Constructors.
    //
    tServiceWithMaxAndMaxAttributes (const max_type&);

    tServiceWithMaxAndMaxAttributes (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    tServiceWithMaxAndMaxAttributes (const tServiceWithMaxAndMaxAttributes& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual tServiceWithMaxAndMaxAttributes*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tServiceWithMaxAndMaxAttributes ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    maxAttributes_optional maxAttributes_;
  };

  class tServiceWithMaxAndModify: public ::SCL::tServiceWithMax
  {
    public:
    // modify
    // 
    typedef ::xml_schema::boolean modify_type;
    typedef ::xsd::cxx::tree::traits< modify_type, char > modify_traits;

    const modify_type&
    modify () const;

    modify_type&
    modify ();

    void
    modify (const modify_type& x);

    static modify_type
    modify_default_value ();

    // Constructors.
    //
    tServiceWithMaxAndModify (const max_type&);

    tServiceWithMaxAndModify (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    tServiceWithMaxAndModify (const tServiceWithMaxAndModify& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual tServiceWithMaxAndModify*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tServiceWithMaxAndModify ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< modify_type > modify_;
  };

  class tServiceWithMaxAndMaxAttributesAndModify: public ::SCL::tServiceWithMaxAndMaxAttributes
  {
    public:
    // modify
    // 
    typedef ::xml_schema::boolean modify_type;
    typedef ::xsd::cxx::tree::traits< modify_type, char > modify_traits;

    const modify_type&
    modify () const;

    modify_type&
    modify ();

    void
    modify (const modify_type& x);

    static modify_type
    modify_default_value ();

    // Constructors.
    //
    tServiceWithMaxAndMaxAttributesAndModify (const max_type&);

    tServiceWithMaxAndMaxAttributesAndModify (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    tServiceWithMaxAndMaxAttributesAndModify (const tServiceWithMaxAndMaxAttributesAndModify& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual tServiceWithMaxAndMaxAttributesAndModify*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tServiceWithMaxAndMaxAttributesAndModify ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< modify_type > modify_;
  };

  class tClientServices: public ::xml_schema::type
  {
    public:
    // goose
    // 
    typedef ::xml_schema::boolean goose_type;
    typedef ::xsd::cxx::tree::traits< goose_type, char > goose_traits;

    const goose_type&
    goose () const;

    goose_type&
    goose ();

    void
    goose (const goose_type& x);

    static goose_type
    goose_default_value ();

    // gsse
    // 
    typedef ::xml_schema::boolean gsse_type;
    typedef ::xsd::cxx::tree::traits< gsse_type, char > gsse_traits;

    const gsse_type&
    gsse () const;

    gsse_type&
    gsse ();

    void
    gsse (const gsse_type& x);

    static gsse_type
    gsse_default_value ();

    // bufReport
    // 
    typedef ::xml_schema::boolean bufReport_type;
    typedef ::xsd::cxx::tree::traits< bufReport_type, char > bufReport_traits;

    const bufReport_type&
    bufReport () const;

    bufReport_type&
    bufReport ();

    void
    bufReport (const bufReport_type& x);

    static bufReport_type
    bufReport_default_value ();

    // unbufReport
    // 
    typedef ::xml_schema::boolean unbufReport_type;
    typedef ::xsd::cxx::tree::traits< unbufReport_type, char > unbufReport_traits;

    const unbufReport_type&
    unbufReport () const;

    unbufReport_type&
    unbufReport ();

    void
    unbufReport (const unbufReport_type& x);

    static unbufReport_type
    unbufReport_default_value ();

    // readLog
    // 
    typedef ::xml_schema::boolean readLog_type;
    typedef ::xsd::cxx::tree::traits< readLog_type, char > readLog_traits;

    const readLog_type&
    readLog () const;

    readLog_type&
    readLog ();

    void
    readLog (const readLog_type& x);

    static readLog_type
    readLog_default_value ();

    // Constructors.
    //
    tClientServices ();

    tClientServices (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    tClientServices (const tClientServices& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual tClientServices*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tClientServices ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< goose_type > goose_;
    ::xsd::cxx::tree::one< gsse_type > gsse_;
    ::xsd::cxx::tree::one< bufReport_type > bufReport_;
    ::xsd::cxx::tree::one< unbufReport_type > unbufReport_;
    ::xsd::cxx::tree::one< readLog_type > readLog_;
  };

  class tServiceSettings: public ::xml_schema::type
  {
    public:
    // cbName
    // 
    typedef ::SCL::tServiceSettingsEnum cbName_type;
    typedef ::xsd::cxx::tree::traits< cbName_type, char > cbName_traits;

    const cbName_type&
    cbName () const;

    cbName_type&
    cbName ();

    void
    cbName (const cbName_type& x);

    void
    cbName (::std::auto_ptr< cbName_type > p);

    static const cbName_type&
    cbName_default_value ();

    // datSet
    // 
    typedef ::SCL::tServiceSettingsEnum datSet_type;
    typedef ::xsd::cxx::tree::traits< datSet_type, char > datSet_traits;

    const datSet_type&
    datSet () const;

    datSet_type&
    datSet ();

    void
    datSet (const datSet_type& x);

    void
    datSet (::std::auto_ptr< datSet_type > p);

    static const datSet_type&
    datSet_default_value ();

    // Constructors.
    //
    tServiceSettings ();

    tServiceSettings (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    tServiceSettings (const tServiceSettings& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual tServiceSettings*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tServiceSettings ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< cbName_type > cbName_;
    static const cbName_type cbName_default_value_;
    ::xsd::cxx::tree::one< datSet_type > datSet_;
    static const datSet_type datSet_default_value_;
  };

  class tReportSettings: public ::SCL::tServiceSettings
  {
    public:
    // rptID
    // 
    typedef ::SCL::tServiceSettingsEnum rptID_type;
    typedef ::xsd::cxx::tree::traits< rptID_type, char > rptID_traits;

    const rptID_type&
    rptID () const;

    rptID_type&
    rptID ();

    void
    rptID (const rptID_type& x);

    void
    rptID (::std::auto_ptr< rptID_type > p);

    static const rptID_type&
    rptID_default_value ();

    // optFields
    // 
    typedef ::SCL::tServiceSettingsEnum optFields_type;
    typedef ::xsd::cxx::tree::traits< optFields_type, char > optFields_traits;

    const optFields_type&
    optFields () const;

    optFields_type&
    optFields ();

    void
    optFields (const optFields_type& x);

    void
    optFields (::std::auto_ptr< optFields_type > p);

    static const optFields_type&
    optFields_default_value ();

    // bufTime
    // 
    typedef ::SCL::tServiceSettingsEnum bufTime_type;
    typedef ::xsd::cxx::tree::traits< bufTime_type, char > bufTime_traits;

    const bufTime_type&
    bufTime () const;

    bufTime_type&
    bufTime ();

    void
    bufTime (const bufTime_type& x);

    void
    bufTime (::std::auto_ptr< bufTime_type > p);

    static const bufTime_type&
    bufTime_default_value ();

    // trgOps
    // 
    typedef ::SCL::tServiceSettingsEnum trgOps_type;
    typedef ::xsd::cxx::tree::traits< trgOps_type, char > trgOps_traits;

    const trgOps_type&
    trgOps () const;

    trgOps_type&
    trgOps ();

    void
    trgOps (const trgOps_type& x);

    void
    trgOps (::std::auto_ptr< trgOps_type > p);

    static const trgOps_type&
    trgOps_default_value ();

    // intgPd
    // 
    typedef ::SCL::tServiceSettingsEnum intgPd_type;
    typedef ::xsd::cxx::tree::traits< intgPd_type, char > intgPd_traits;

    const intgPd_type&
    intgPd () const;

    intgPd_type&
    intgPd ();

    void
    intgPd (const intgPd_type& x);

    void
    intgPd (::std::auto_ptr< intgPd_type > p);

    static const intgPd_type&
    intgPd_default_value ();

    // Constructors.
    //
    tReportSettings ();

    tReportSettings (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    tReportSettings (const tReportSettings& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual tReportSettings*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tReportSettings ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< rptID_type > rptID_;
    static const rptID_type rptID_default_value_;
    ::xsd::cxx::tree::one< optFields_type > optFields_;
    static const optFields_type optFields_default_value_;
    ::xsd::cxx::tree::one< bufTime_type > bufTime_;
    static const bufTime_type bufTime_default_value_;
    ::xsd::cxx::tree::one< trgOps_type > trgOps_;
    static const trgOps_type trgOps_default_value_;
    ::xsd::cxx::tree::one< intgPd_type > intgPd_;
    static const intgPd_type intgPd_default_value_;
  };

  class tLogSettings: public ::SCL::tServiceSettings
  {
    public:
    // logEna
    // 
    typedef ::SCL::tServiceSettingsEnum logEna_type;
    typedef ::xsd::cxx::tree::traits< logEna_type, char > logEna_traits;

    const logEna_type&
    logEna () const;

    logEna_type&
    logEna ();

    void
    logEna (const logEna_type& x);

    void
    logEna (::std::auto_ptr< logEna_type > p);

    static const logEna_type&
    logEna_default_value ();

    // trgOps
    // 
    typedef ::SCL::tServiceSettingsEnum trgOps_type;
    typedef ::xsd::cxx::tree::traits< trgOps_type, char > trgOps_traits;

    const trgOps_type&
    trgOps () const;

    trgOps_type&
    trgOps ();

    void
    trgOps (const trgOps_type& x);

    void
    trgOps (::std::auto_ptr< trgOps_type > p);

    static const trgOps_type&
    trgOps_default_value ();

    // intgPd
    // 
    typedef ::SCL::tServiceSettingsEnum intgPd_type;
    typedef ::xsd::cxx::tree::traits< intgPd_type, char > intgPd_traits;

    const intgPd_type&
    intgPd () const;

    intgPd_type&
    intgPd ();

    void
    intgPd (const intgPd_type& x);

    void
    intgPd (::std::auto_ptr< intgPd_type > p);

    static const intgPd_type&
    intgPd_default_value ();

    // Constructors.
    //
    tLogSettings ();

    tLogSettings (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    tLogSettings (const tLogSettings& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual tLogSettings*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tLogSettings ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< logEna_type > logEna_;
    static const logEna_type logEna_default_value_;
    ::xsd::cxx::tree::one< trgOps_type > trgOps_;
    static const trgOps_type trgOps_default_value_;
    ::xsd::cxx::tree::one< intgPd_type > intgPd_;
    static const intgPd_type intgPd_default_value_;
  };

  class tGSESettings: public ::SCL::tServiceSettings
  {
    public:
    // appID
    // 
    typedef ::SCL::tServiceSettingsEnum appID_type;
    typedef ::xsd::cxx::tree::traits< appID_type, char > appID_traits;

    const appID_type&
    appID () const;

    appID_type&
    appID ();

    void
    appID (const appID_type& x);

    void
    appID (::std::auto_ptr< appID_type > p);

    static const appID_type&
    appID_default_value ();

    // dataLabel
    // 
    typedef ::SCL::tServiceSettingsEnum dataLabel_type;
    typedef ::xsd::cxx::tree::traits< dataLabel_type, char > dataLabel_traits;

    const dataLabel_type&
    dataLabel () const;

    dataLabel_type&
    dataLabel ();

    void
    dataLabel (const dataLabel_type& x);

    void
    dataLabel (::std::auto_ptr< dataLabel_type > p);

    static const dataLabel_type&
    dataLabel_default_value ();

    // Constructors.
    //
    tGSESettings ();

    tGSESettings (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    tGSESettings (const tGSESettings& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual tGSESettings*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tGSESettings ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< appID_type > appID_;
    static const appID_type appID_default_value_;
    ::xsd::cxx::tree::one< dataLabel_type > dataLabel_;
    static const dataLabel_type dataLabel_default_value_;
  };

  class tSMVSettings: public ::SCL::tServiceSettings
  {
    public:
    // SmpRate1
    // 
    typedef ::SCL::SmpRate1 SmpRate1_type;
    typedef ::xsd::cxx::tree::sequence< SmpRate1_type > SmpRate1_sequence;
    typedef SmpRate1_sequence::iterator SmpRate1_iterator;
    typedef SmpRate1_sequence::const_iterator SmpRate1_const_iterator;
    typedef ::xsd::cxx::tree::traits< SmpRate1_type, char > SmpRate1_traits;

    const SmpRate1_sequence&
    SmpRate1 () const;

    SmpRate1_sequence&
    SmpRate1 ();

    void
    SmpRate1 (const SmpRate1_sequence& s);

    // svID
    // 
    typedef ::SCL::tServiceSettingsEnum svID_type;
    typedef ::xsd::cxx::tree::traits< svID_type, char > svID_traits;

    const svID_type&
    svID () const;

    svID_type&
    svID ();

    void
    svID (const svID_type& x);

    void
    svID (::std::auto_ptr< svID_type > p);

    static const svID_type&
    svID_default_value ();

    // optFields
    // 
    typedef ::SCL::tServiceSettingsEnum optFields_type;
    typedef ::xsd::cxx::tree::traits< optFields_type, char > optFields_traits;

    const optFields_type&
    optFields () const;

    optFields_type&
    optFields ();

    void
    optFields (const optFields_type& x);

    void
    optFields (::std::auto_ptr< optFields_type > p);

    static const optFields_type&
    optFields_default_value ();

    // smpRate2
    // 
    typedef ::SCL::tServiceSettingsEnum smpRate2_type;
    typedef ::xsd::cxx::tree::traits< smpRate2_type, char > smpRate2_traits;

    const smpRate2_type&
    smpRate2 () const;

    smpRate2_type&
    smpRate2 ();

    void
    smpRate2 (const smpRate2_type& x);

    void
    smpRate2 (::std::auto_ptr< smpRate2_type > p);

    static const smpRate2_type&
    smpRate2_default_value ();

    // Constructors.
    //
    tSMVSettings ();

    tSMVSettings (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    tSMVSettings (const tSMVSettings& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual tSMVSettings*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tSMVSettings ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SmpRate1_sequence SmpRate1_;
    ::xsd::cxx::tree::one< svID_type > svID_;
    static const svID_type svID_default_value_;
    ::xsd::cxx::tree::one< optFields_type > optFields_;
    static const optFields_type optFields_default_value_;
    ::xsd::cxx::tree::one< smpRate2_type > smpRate2_;
    static const smpRate2_type smpRate2_default_value_;
  };

  class tConfLNs: public ::xml_schema::type
  {
    public:
    // fixPrefix
    // 
    typedef ::xml_schema::boolean fixPrefix_type;
    typedef ::xsd::cxx::tree::traits< fixPrefix_type, char > fixPrefix_traits;

    const fixPrefix_type&
    fixPrefix () const;

    fixPrefix_type&
    fixPrefix ();

    void
    fixPrefix (const fixPrefix_type& x);

    static fixPrefix_type
    fixPrefix_default_value ();

    // fixLnInst
    // 
    typedef ::xml_schema::boolean fixLnInst_type;
    typedef ::xsd::cxx::tree::traits< fixLnInst_type, char > fixLnInst_traits;

    const fixLnInst_type&
    fixLnInst () const;

    fixLnInst_type&
    fixLnInst ();

    void
    fixLnInst (const fixLnInst_type& x);

    static fixLnInst_type
    fixLnInst_default_value ();

    // Constructors.
    //
    tConfLNs ();

    tConfLNs (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    tConfLNs (const tConfLNs& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual tConfLNs*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~tConfLNs ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< fixPrefix_type > fixPrefix_;
    ::xsd::cxx::tree::one< fixLnInst_type > fixLnInst_;
  };

  class SettingGroups: public ::xml_schema::type
  {
    public:
    // SGEdit
    // 
    typedef ::SCL::tServiceYesNo SGEdit_type;
    typedef ::xsd::cxx::tree::optional< SGEdit_type > SGEdit_optional;
    typedef ::xsd::cxx::tree::traits< SGEdit_type, char > SGEdit_traits;

    const SGEdit_optional&
    SGEdit () const;

    SGEdit_optional&
    SGEdit ();

    void
    SGEdit (const SGEdit_type& x);

    void
    SGEdit (const SGEdit_optional& x);

    void
    SGEdit (::std::auto_ptr< SGEdit_type > p);

    // ConfSG
    // 
    typedef ::SCL::tServiceYesNo ConfSG_type;
    typedef ::xsd::cxx::tree::optional< ConfSG_type > ConfSG_optional;
    typedef ::xsd::cxx::tree::traits< ConfSG_type, char > ConfSG_traits;

    const ConfSG_optional&
    ConfSG () const;

    ConfSG_optional&
    ConfSG ();

    void
    ConfSG (const ConfSG_type& x);

    void
    ConfSG (const ConfSG_optional& x);

    void
    ConfSG (::std::auto_ptr< ConfSG_type > p);

    // Constructors.
    //
    SettingGroups ();

    SettingGroups (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    SettingGroups (const SettingGroups& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual SettingGroups*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~SettingGroups ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SGEdit_optional SGEdit_;
    ConfSG_optional ConfSG_;
  };

  class Authentication: public ::xml_schema::type
  {
    public:
    // none
    // 
    typedef ::xml_schema::boolean none_type;
    typedef ::xsd::cxx::tree::traits< none_type, char > none_traits;

    const none_type&
    none () const;

    none_type&
    none ();

    void
    none (const none_type& x);

    static none_type
    none_default_value ();

    // password
    // 
    typedef ::xml_schema::boolean password_type;
    typedef ::xsd::cxx::tree::traits< password_type, char > password_traits;

    const password_type&
    password () const;

    password_type&
    password ();

    void
    password (const password_type& x);

    static password_type
    password_default_value ();

    // weak
    // 
    typedef ::xml_schema::boolean weak_type;
    typedef ::xsd::cxx::tree::traits< weak_type, char > weak_traits;

    const weak_type&
    weak () const;

    weak_type&
    weak ();

    void
    weak (const weak_type& x);

    static weak_type
    weak_default_value ();

    // strong
    // 
    typedef ::xml_schema::boolean strong_type;
    typedef ::xsd::cxx::tree::traits< strong_type, char > strong_traits;

    const strong_type&
    strong () const;

    strong_type&
    strong ();

    void
    strong (const strong_type& x);

    static strong_type
    strong_default_value ();

    // certificate
    // 
    typedef ::xml_schema::boolean certificate_type;
    typedef ::xsd::cxx::tree::traits< certificate_type, char > certificate_traits;

    const certificate_type&
    certificate () const;

    certificate_type&
    certificate ();

    void
    certificate (const certificate_type& x);

    static certificate_type
    certificate_default_value ();

    // Constructors.
    //
    Authentication ();

    Authentication (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    Authentication (const Authentication& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual Authentication*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Authentication ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< none_type > none_;
    ::xsd::cxx::tree::one< password_type > password_;
    ::xsd::cxx::tree::one< weak_type > weak_;
    ::xsd::cxx::tree::one< strong_type > strong_;
    ::xsd::cxx::tree::one< certificate_type > certificate_;
  };

  class LN0: public ::SCL::tLN0
  {
    public:
    // Constructors.
    //
    LN0 (const lnType_type&);

    LN0 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    LN0 (const LN0& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    virtual LN0*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~LN0 ();
  };

  class OptFields: public ::xml_schema::type
  {
    public:
    // seqNum
    // 
    typedef ::xml_schema::boolean seqNum_type;
    typedef ::xsd::cxx::tree::traits< seqNum_type, char > seqNum_traits;

    const seqNum_type&
    seqNum () const;

    seqNum_type&
    seqNum ();

    void
    seqNum (const seqNum_type& x);

    static seqNum_type
    seqNum_default_value ();

    // timeStamp
    // 
    typedef ::xml_schema::boolean timeStamp_type;
    typedef ::xsd::cxx::tree::traits< timeStamp_type, char > timeStamp_traits;

    const timeStamp_type&
    timeStamp () const;

    timeStamp_type&
    timeStamp ();

    void
    timeStamp (const timeStamp_type& x);

    static timeStamp_type
    timeStamp_default_value ();

    // dataSet
    // 
    typedef ::xml_schema::boolean dataSet_type;
    typedef ::xsd::cxx::tree::traits< dataSet_type, char > dataSet_traits;

    const dataSet_type&
    dataSet () const;

    dataSet_type&
    dataSet ();

    void
    dataSet (const dataSet_type& x);

    static dataSet_type
    dataSet_default_value ();

    // reasonCode
    // 
    typedef ::xml_schema::boolean reasonCode_type;
    typedef ::xsd::cxx::tree::traits< reasonCode_type, char > reasonCode_traits;

    const reasonCode_type&
    reasonCode () const;

    reasonCode_type&
    reasonCode ();

    void
    reasonCode (const reasonCode_type& x);

    static reasonCode_type
    reasonCode_default_value ();

    // dataRef
    // 
    typedef ::xml_schema::boolean dataRef_type;
    typedef ::xsd::cxx::tree::traits< dataRef_type, char > dataRef_traits;

    const dataRef_type&
    dataRef () const;

    dataRef_type&
    dataRef ();

    void
    dataRef (const dataRef_type& x);

    static dataRef_type
    dataRef_default_value ();

    // bufOvfl
    // 
    typedef ::xml_schema::boolean bufOvfl_type;
    typedef ::xsd::cxx::tree::traits< bufOvfl_type, char > bufOvfl_traits;

    const bufOvfl_type&
    bufOvfl () const;

    bufOvfl_type&
    bufOvfl ();

    void
    bufOvfl (const bufOvfl_type& x);

    static bufOvfl_type
    bufOvfl_default_value ();

    // entryID
    // 
    typedef ::xml_schema::boolean entryID_type;
    typedef ::xsd::cxx::tree::traits< entryID_type, char > entryID_traits;

    const entryID_type&
    entryID () const;

    entryID_type&
    entryID ();

    void
    entryID (const entryID_type& x);

    static entryID_type
    entryID_default_value ();

    // configRef
    // 
    typedef ::xml_schema::boolean configRef_type;
    typedef ::xsd::cxx::tree::traits< configRef_type, char > configRef_traits;

    const configRef_type&
    configRef () const;

    configRef_type&
    configRef ();

    void
    configRef (const configRef_type& x);

    static configRef_type
    configRef_default_value ();

    // Constructors.
    //
    OptFields ();

    OptFields (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    OptFields (const OptFields& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual OptFields*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~OptFields ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< seqNum_type > seqNum_;
    ::xsd::cxx::tree::one< timeStamp_type > timeStamp_;
    ::xsd::cxx::tree::one< dataSet_type > dataSet_;
    ::xsd::cxx::tree::one< reasonCode_type > reasonCode_;
    ::xsd::cxx::tree::one< dataRef_type > dataRef_;
    ::xsd::cxx::tree::one< bufOvfl_type > bufOvfl_;
    ::xsd::cxx::tree::one< entryID_type > entryID_;
    ::xsd::cxx::tree::one< configRef_type > configRef_;
  };

  class SmvOpts: public ::xml_schema::type
  {
    public:
    // refreshTime
    // 
    typedef ::xml_schema::boolean refreshTime_type;
    typedef ::xsd::cxx::tree::traits< refreshTime_type, char > refreshTime_traits;

    const refreshTime_type&
    refreshTime () const;

    refreshTime_type&
    refreshTime ();

    void
    refreshTime (const refreshTime_type& x);

    static refreshTime_type
    refreshTime_default_value ();

    // sampleSynchronized
    // 
    typedef ::xml_schema::boolean sampleSynchronized_type;
    typedef ::xsd::cxx::tree::traits< sampleSynchronized_type, char > sampleSynchronized_traits;

    const sampleSynchronized_type&
    sampleSynchronized () const;

    static sampleSynchronized_type
    sampleSynchronized_default_value ();

    // sampleRate
    // 
    typedef ::xml_schema::boolean sampleRate_type;
    typedef ::xsd::cxx::tree::traits< sampleRate_type, char > sampleRate_traits;

    const sampleRate_type&
    sampleRate () const;

    sampleRate_type&
    sampleRate ();

    void
    sampleRate (const sampleRate_type& x);

    static sampleRate_type
    sampleRate_default_value ();

    // dataSet
    // 
    typedef ::xml_schema::boolean dataSet_type;
    typedef ::xsd::cxx::tree::traits< dataSet_type, char > dataSet_traits;

    const dataSet_type&
    dataSet () const;

    dataSet_type&
    dataSet ();

    void
    dataSet (const dataSet_type& x);

    static dataSet_type
    dataSet_default_value ();

    // security
    // 
    typedef ::xml_schema::boolean security_type;
    typedef ::xsd::cxx::tree::traits< security_type, char > security_traits;

    const security_type&
    security () const;

    security_type&
    security ();

    void
    security (const security_type& x);

    static security_type
    security_default_value ();

    // Constructors.
    //
    SmvOpts ();

    SmvOpts (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    SmvOpts (const SmvOpts& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual SmvOpts*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~SmvOpts ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< refreshTime_type > refreshTime_;
    ::xsd::cxx::tree::one< sampleSynchronized_type > sampleSynchronized_;
    ::xsd::cxx::tree::one< sampleRate_type > sampleRate_;
    ::xsd::cxx::tree::one< dataSet_type > dataSet_;
    ::xsd::cxx::tree::one< security_type > security_;
  };

  class SmpRate1: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // Constructors.
    //
    SmpRate1 (const ::xml_schema::decimal&);

    SmpRate1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    SmpRate1 (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    SmpRate1 (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    SmpRate1 (const SmpRate1& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual SmpRate1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~SmpRate1 ();
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace SCL
{
  // Parse a URI or a local file.
  //

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (const ::std::string& uri,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (const ::std::string& uri,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (const ::std::string& uri,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse std::istream.
  //

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        const ::std::string& id,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::InputSource.
  //

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::xercesc::InputSource& is,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::xercesc::InputSource& is,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::xercesc::InputSource& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // SCL_IED_HXX
